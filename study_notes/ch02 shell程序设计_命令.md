# 命令

在shell脚本程序内部，可以执行两类命令：一类是可以在命令提示符中执行的“普通”命令，也称为外部命令（external command），一类是“内置”命令，也称为内部命令（internal command）。

内置命令是在shell内部实现的，不能作为外部程序被调用。然而，大多数的内置命令同时也提供了独立运行的程序版本。

## break命令

用于跳出for, while或until循环。

## :命令

冒号命令是一个空命令。

它偶尔会被用于简化条件逻辑，相当于true的一个别名。while :实现了一个无限循环，可代替更常见的while true

: 结构也会被用在变量的条件设置中，例如：

```
: ${var:=value}
```

## continue命令

使for, while或until循环跳到下一次循环继续执行。循环变量取值循环列表中下一个值。

## .命令

点命令用于在当前shell中执行命令：

```
. ./shell_script
```

当一个脚本执行一条外部命令或脚本程序时，它会创建一个新的环境（一个子shell），命令将在这个新环境中执行，在命令执行完毕后，这个环境被丢弃，留下退出码返回给父shell。

但外部的source命令和点命令在执行脚本中列出的命令时，使用的是调用该脚本程序的同一个shell。

点命令允许执行的脚本程序改变当前环境。

## echo命令

一个常见的问题是如何去掉换行符，Linux常用的解决方法是：

```
echo -n "string to output"
```

还可以：

```
echo -e "string to output\c"
```

echo -e确保启用了反斜线转义字符（\c代表去掉换行符，\t代表制表符，\n代表回车）。

## eval命令

eval命令允许你对参数进行求职。见书本。

## exec命令

典型用法是将当前shell替换为一个不同的程序。如：

```
exec wall "Thanks for all the fish"
```

## exit n命令

exit命令使脚本程序以退出码n结束运行。如果在任何一个交互式shell的命令提示符中使用这个命令，它会使你退出系统。

如果你允许自己的脚本程序在退出时不指定一个退出状态，那么该脚本中最后一条被执行命令的状态将被用作返回值。

在shell脚本编程中，退出码0表示成功，1~125是脚本程序可以使用的错误代码。其余数字具有保留含义。

## export命令

export命令将作为它参数的变量导出到子shell中，并使之在子shell中有效。

默认情况下，在一个shell中被创建的变量在这个shell调用的下级shell中是不可用的。export命令把自己的参数创建为一个环境变量，而这个环境变量可以被当前程序调用的其他脚本和程序看见。

## expr命令

expr把参数当成表达式来进行算术运算，然后输出运算结果。对于比较运算，如果为真返回1，否则返回0。

expr支持的运算有：四则运算，求余，比较运算（=，>, <）等。

## printf命令

语法是：

```
printf "format string" param1 param2
```

转义序列和转换说明见书本。

## return命令

return命令的作用是使函数返回。return命令有一个数值参数的返回值。如果没有指定参数，return命令默认返回最后一条命令的退出码。

## set命令

set命令的作用是为shell设置参数变量。

## shift命令

shift命令把所有参数变量左移一个位置，使$2变成$1，$3变成$2，以此类推。原来的$1将被丢弃，而$0仍将保持不变。

如果脚本程序需要10个或10个以上的参数，就需要使用shift命令来访问第十个及其后面的参数。

## trap命令

trap命令用于指定在接收到信号后将要采取的行动。

可以使用trap -l来查看信号编号及其关联的名称。

信号是指那些被异步发送到一个程序的事件。在默认情况下，它们通常会终止一个程序的运行、

trap命令有两个参数，第一个参数是接收到指定信号时将要采取的行动，第二个参数是要处理的信号名：

```
trap command signal
```

如果想重置某个信号的处理方式到其默认值，只需将command设置为-。如果要忽略某个信号，就把command设置为空字符串''。

## unset命令

unset命令的作用是从环境中删除变量或函数。

## find命令

find命令是一个用于搜索文件的命令。如：

```
# find / -name test -print
```

这个命令的含义是：从根目录开始查找名为test的文件，并且输出该文件的完整路径。

find命令的完整语法格式是：

```
find [path] [options] [tests] [actions]
```

path既可以是绝对路径，也可以是相对路径，如果需要，还可以指定多个路径，如：`find /var /home`

find命令有许多options可用，见书本。

可以提供给find命令的测试非常多，测试返回的结果有true或false。find命令开始工作时，它按照顺序将定义的每种测试依次应用到它搜索到的每个文件上。如果一个测试返回false，find命令就停止处理它当前找到的找个文件，并继续搜索。如果一个测试返回true，find命令将继续下一个测试或对当前文件采取行动。

常用测试见书本。

发现匹配指定条件的文件之后，就可以对其执行动作了。魔术字符串{}是-exec或-ok命令的一个特殊类型的参数，它被当前文件的完整路径所取代。见书本。

## grep命令与正则表达式

grep代表的是**通用正则表达式解析器**（General Regular Expression Parser）。grep命令在文件中搜索字符串。

grep命令的语法如下：

```
grep [options] PATTERN [FILES]
```

如果没有提供文件名，grep命令将搜索标准输入。

grep的一些主要的选项如下：

|选项|含义|
|-|-|
|-c|输出匹配行的数目，而不是输出匹配的行|
|-E|启用扩展表达式|
|-h|取消每个输出行的普通前缀，即匹配查询模式的文件名|
|-i|忽略大小写|
|-l|只列出包含匹配行的文件名，而不输出真正的匹配行|
|-v|对匹配模式取反，即搜索不匹配行而不是匹配行|

**正则表达式**

正则表达式允许你实现更复杂的匹配。

正则表达式中的一些字符是以特定方式处理的，见书本。

# 命令的执行

## 获取命令输出

有两种方法可以获得命令输出的结果：

- 使用`$(command)`语法

- 或者使用如下方法，这种比较古老
```
`command`
```

## 算术扩展

除了可以使用expr命令获得算术运算的输出结果，还可以使用如下方法：
```
$((...))
```

在`...`中的可以是某些算术运算。如果引用了变量，那么不需要在前面加$来引用。

这样做更加灵活，因为可以算术运算内容可以是一个字符串，运算符两边不需要加空格，还可以进行多项式的运算。

## 参数扩展（Parameter Expansion）

你可以在shell中采用多种参数替换方法。对于多参数处理问题来说，这些方法通常会提供一种精巧的解决方案。

|参数扩展|说明|
|-|-|
|${param:-default}|如果param为空，就把它设置为default的值|
|${#param}|给出param的长度|
|${param%word}|从param的尾部开始删除与word匹配的最小部分，然后返回剩余部分|
|${param%%word}|从param的尾部开始删除与word匹配的最长部分，然后返回剩余部分|
|${param#word}|从param的头部开始删除与word匹配的最小部分，然后返回剩余部分|
|${param##word}|从param的头部开始删除与word匹配的最长部分，然后返回剩余部分|
|${param//pattern/string}|对所有的匹配执行替换|

虽然看上去比较难理解，但如果结合例子就很容易了。例子在书本p60以及代码笔记。

还有一种扩展方法如：

`${i}_tmp`，这种方法会把i扩展，而保留tmp。假如i=1，扩展的结果是1_tmp。