{
    "docs": [
        {
            "location": "/", 
            "text": "资料\n\n\n\n\nLinux程序设计 第4版", 
            "title": "Home"
        }, 
        {
            "location": "/#_1", 
            "text": "Linux程序设计 第4版", 
            "title": "资料"
        }, 
        {
            "location": "/ch01 入门/", 
            "text": "UNIX、Linux和GNU简介\n\n\nLinux现已成为一个切实可行的操作系统，特别是在服务器市场中。\n\n\nLinux的成功要归功于在它之前诞生的系统和应用程序——UNIX和GNU软件。\n\n\n什么是UNIX\n\n\nUNIX操作系统最初是由贝尔实验室开发的。UNIX现已成为一种非常流行的多用户、多任务操作系统。UNIX操作系统可以运行在大量不同种类的硬件平台上。\n\n\nUNIX哲学\n\n\nUNIX操作系统（包括Linux）鼓励一种特定的编程风格。下面列出了一些典型的UNIX程序和系统所具有的特点。\n\n\n- \n简单性\n。“小而简单”（KISS, Keep It Small and Simple）是一种值得学习的技术。\n\n\n- \n集中性\n。在UNIX中，通常把小工具组合起来以完成复杂的任务，而不是试图将一个用户期望的所有功能放在一个大程序里。\n\n\n- \n可重用组件\n。将应用程序的核心实现为库。\n\n\n- \n过滤器\n。许多UNIX应用程序可用作过滤器，它们对输入进行转换并产生输出。\n\n\n比较详细的介绍见书本p2。\n\n\n什么是Linux\n\n\nLinux是一个可以自由发布的类UNIX内核实现，它是一个操作系统的底层核心。它是由赫尔基辛大学的Linux Torvalds开发的，期间得到了因特网上广大UNIX程序员的帮助。\n\n\nGNU项目和自由软件基金会\n\n\n操作系统内核本身仅仅是可用开发系统的一小部分。传统上，商业化的UNIX系统都包含提供系统服务和工具的应用程序。对于Linux系统来说，这些额外的程序是由许多程序员编写并自由发布的。\n\n\nGNU项目是由Richard Stallman发起的，它为软件社区提供了许多UNIX系统上应用程序的仿制品。所有这些程序，即GNU软件，都是在GNU通用公共许可证（GPL）的条款下发布的。\n\n\n可以在 http://www.gnu.org 上找到更多关于自由软件的概念。\n\n\nLinux发行版\n\n\nLinux实际上只是一个内核。你可以获得内核源代码，编译并安装它，然后获得并安装许多其他自由发布的软件，从而完成一个完整的Linux系统的安装。\n\n\n但这样的安装并非易事，幸运的是，许多人制作了Linux发行版，它不仅包含内核，还包含许多其他编程工具和应用程序。它通常都会包含一个X视窗系统的实现，即一个图形化环境。Linux发行版通常还带有安装程序和附加文档（一般在CD上），帮助你安装自己的Linux系统。\n\n\n\n\nmy note: 学习中，我使用的Linux发行版是centos 7，官网是：https://www.centos.org/\n\n\n\n\nLinux程序设计\n\n\nUNIX最初是用C语言编写的，并且UNIX的大多数应用程序也是用C语言编写的，但C语言并不是Linux程序员或UNIX程序员的唯一选择。\n\n\n\n\nmy note: 还有许多其他的语言可以选择，不过书中主要讲解的是shell和C语言。\n\n\n\n\nLinux程序\n\n\nLinux应用程序表现为两种特殊类型的文件，可执行文件和脚本文件。可执行文件是计算机可以直接运行的程序，它们相当于Windows中的.exe文件。脚本文件是一组指令的集合，这些指令将由另一个程序（解释器）来执行，相当于Windows的bat文件。\n\n\n当登陆进Linux系统时，你与一个shell程序进行交互，它像Windows中的命令提示窗口一样运行程序。它在一组指定的目录路径下按照你给出的程序名搜索与之同名的文件。搜索目录路径存储在shell变量PATH里。\n\n\n\n\nmy note: PATH变量定义在文件~/.bash_profile中。\n\n\n\n\n文本编辑器\n\n\n本书的两位作者都喜欢Emacs，并建议读者花一点时间来学习这个功能强大的编辑器。\n\n\n\n\nmy note: 不过我使用vim，目前感觉足够了。\n\n\n\n\nC语言编译器\n\n\n在本书中，我们将使用gcc，这是因为它随Linux的发行版一起提供，并且它支持C语言的ANSI标准语法。\n\n\n当用gcc命令生成一个可执行程序后（比如gcc -o hello hello.c），可用下面的命令执行此程序：\n\n\n./hello\n\n\n\n\n在程序名前加上一个./特别指示shell去执行当前目录下的程序。\n\n\n如果不使用-o name选项告诉编译器可执行程序的名字，编译器就会把程序放在一个名为a.out的文件里（含义是assembler output，即汇编输出）。\n\n\n开发系统导引\n\n\n对Linux开发人员来说，了解软件工具和开发资源在系统中存放的位置是很重要的。以下几节介绍一些重要的目录和文件。\n\n\n应用程序\n\n\n系统为正常使用提供的程序，包括用于程序开发的工具，都可在目录/usr/bin中找到；系统管理员为某个特定的主机或本地网络添加的程序通常可在目录/usr/local/bin或/opt中找到。\n\n\n我们建议对于系统级的应用程序，你可以将它放在/usr/local目录中来运行和访问所需的文件。对于开发用和个人的应用程序，最好在你的家目录中使用一个文件夹来存放它。\n\n\n\n\nmy note: 我写了一个脚本，放在utility目录下，叫findcmd，可以查看这些程序所在的目录。\n\n\n\n\n头文件\n\n\n用C语言进行程序设计时，你需要用头文件来提供对常量的定义和对系统函数及库函数调用的声明。对C语言来说，这些头文件几乎总是位于/usr/include目录及其子目录中。\n\n\n在调用C语言编译器时，你可以使用-I标志来包含保存在子目录或非标准位置中的头文件。例如：\n\n\n$ gcc -I/usr/openwin/include fred.c\n\n\n\n\n它指示编译器不仅在标准位置，也在/usr/openwin/include目录中查找程序fred.c中包含的头文件。\n\n\n更多细节可以参看使用手册：man gcc\n\n\n用grep命令来搜索包含某些特定定义和函数原型的头文件是很方便的。比如：\n\n\ngrep EXIT_ /usr/include/*.h\n\n\n\n\n可以查看到退出状态的定义。\n\n\n库文件\n\n\n库是一组预先编译好的函数的集合，这些函数都是按照可重用的原则编写的。\n\n\n标准系统库文件一般存储在/lib和/usr/lib目录中。C语言编译器需要知道要搜索哪些库文件，因为在默认情况下，它只搜索标准C语言库。库文件还必须遵循特定的命名规范并且要在命令行中明确指定。\n\n\n库文件的名字总是以lib开头，随后的部分指明这是什么库，之后是后缀，给出库文件的类型：\n\n\n- .a代表传统的静态函数库；\n- .so代表共享函数库。\n\n\n函数库通常同时以静态库和共享库两种格式存在。可以通过完整的库文件路径名或用-l标志来告诉编译器要搜索的库文件。例如：\n\n\n$ gcc -o fred fred.c /usr/lib/libm.a\n$ gcc -o fred fred.c -lm\n\n\n\n\n-lm代表标准库目录中名为libm.a的函数库。-lm标志的另一个好处是如果有共享库，编译器会自动选择共享库。\n\n\n可以通过使用-L标志位编译器增加库的搜索路径。例如：\n\n\n$ gcc -o x11fred -L/usr/openwin/lib x11fred.c -lX11\n\n\n\n\n静态库\n\n\n函数库最简单的形式是一组处于“准备好使用”状态的目标文件。程序包含库函数的头文件，编译器和链接器负责将程序代码和函数库结合在一起以组成一个单独的可执行文件。你必须使用-l选项指明除标准C语言运行库外还需使用的库。\n\n\n静态库也称作归档文件（archive），使用gcc -c命令和ar命令就可以创建静态库。\n\n\n举个例子：\n\n\n$ gcc -c bill.c fred.c\n$ ar crv libfoo.a bill.o fred.o\n$ gcc -o program program.o libfoo.a\n\n\n\n\ngcc的-c选项阻止编译器创建一个完整的程序，只生成一份目标文件。\n\n\nar命令用来创建归档文件。接着就可以引入此静态库了。\n\n\n你也可以使用-l选项来访问函数库，但因其未保存在标准位置，所以你必须使用-L选项来告诉编译器在何处可以找到它，如下所示：\n\n\n$ gcc -o program program.o -L. -lfoo\n\n\n\n\n如有要查看哪些函数被包含在目标文件、函数库或可执行文件里，你可以使用nm命令。当程序被创建时，它只包含函数库中它实际需要的函数。\n\n\nWindows下有许多相似之处：\n\n\n|项目|UNIX|Windows|\n|-|-|\n|目标模块|func.o|FUNC.OBJ|\n|静态函数库|lib.a|LIB.LIB|\n|程序|program|PROGRAM.EXE|\n\n\n共享库\n\n\n静态库的一个缺点是，当同时运行的程序中都使用了同一个函数库的函数时，内存中就会有同一函数的多份副本。且程序文件中也包含了副本。这将消耗大量宝贵的内存和磁盘空间。\n\n\n共享库可以克服上述不足。\n\n\n当一个程序使用共享库时，它的链接方式是这样的：程序本身不再包含函数代码，而是引用运行时可访问的共享代码。\n\n\n通过这种方法，系统可以只保留共享库的一份副本供许多程序同时使用，并且在磁盘上也仅保存一份。另一个好处是共享库的更新可以独立于依赖它的应用程序，例如，文件/lib/libm.so实际上是/lib/libm.so.N的符号链接，其中N代表主版本号。\n\n\n对Linux系统来说，负责装载共享库并解析客户程序函数引用的程序是ld.so。用于搜索共享库的额外位置可以在文件/etc/ld.so.conf中配置，如果修改了这个文件，你需要执行命令ldconfig来处理它。\n\n\n你可以通过运行工具ldd来查看一个程序需要的共享库。如：\n\n\n$ ldd program\n\n\n\n\n生成共享库的命令可以是：\n\n\ngcc -shared -o libfunctions.so -fPIC libfunctions.c\n\n\n\n\n链接共享库的方法和静态库一样。但使用前需要配置过一次ldconfig，即此共享库所在的目录已配置在/etc/ld.so.conf中，并执行过一次ldconfig命令。\n\n\n获得帮助\n\n\nman命令可以用来访问在线手册页。\n\n\nGNU软件和其他一些自由软件还使用名为info的在线文档系统。你可以通过专用程序info或通过emacs编辑器中的info命令来在线浏览全部的文档。", 
            "title": "ch01 入门"
        }, 
        {
            "location": "/ch01 入门/#unixlinuxgnu", 
            "text": "Linux现已成为一个切实可行的操作系统，特别是在服务器市场中。  Linux的成功要归功于在它之前诞生的系统和应用程序——UNIX和GNU软件。", 
            "title": "UNIX、Linux和GNU简介"
        }, 
        {
            "location": "/ch01 入门/#unix", 
            "text": "UNIX操作系统最初是由贝尔实验室开发的。UNIX现已成为一种非常流行的多用户、多任务操作系统。UNIX操作系统可以运行在大量不同种类的硬件平台上。  UNIX哲学  UNIX操作系统（包括Linux）鼓励一种特定的编程风格。下面列出了一些典型的UNIX程序和系统所具有的特点。  -  简单性 。“小而简单”（KISS, Keep It Small and Simple）是一种值得学习的技术。  -  集中性 。在UNIX中，通常把小工具组合起来以完成复杂的任务，而不是试图将一个用户期望的所有功能放在一个大程序里。  -  可重用组件 。将应用程序的核心实现为库。  -  过滤器 。许多UNIX应用程序可用作过滤器，它们对输入进行转换并产生输出。  比较详细的介绍见书本p2。", 
            "title": "什么是UNIX"
        }, 
        {
            "location": "/ch01 入门/#linux", 
            "text": "Linux是一个可以自由发布的类UNIX内核实现，它是一个操作系统的底层核心。它是由赫尔基辛大学的Linux Torvalds开发的，期间得到了因特网上广大UNIX程序员的帮助。", 
            "title": "什么是Linux"
        }, 
        {
            "location": "/ch01 入门/#gnu", 
            "text": "操作系统内核本身仅仅是可用开发系统的一小部分。传统上，商业化的UNIX系统都包含提供系统服务和工具的应用程序。对于Linux系统来说，这些额外的程序是由许多程序员编写并自由发布的。  GNU项目是由Richard Stallman发起的，它为软件社区提供了许多UNIX系统上应用程序的仿制品。所有这些程序，即GNU软件，都是在GNU通用公共许可证（GPL）的条款下发布的。  可以在 http://www.gnu.org 上找到更多关于自由软件的概念。", 
            "title": "GNU项目和自由软件基金会"
        }, 
        {
            "location": "/ch01 入门/#linux_1", 
            "text": "Linux实际上只是一个内核。你可以获得内核源代码，编译并安装它，然后获得并安装许多其他自由发布的软件，从而完成一个完整的Linux系统的安装。  但这样的安装并非易事，幸运的是，许多人制作了Linux发行版，它不仅包含内核，还包含许多其他编程工具和应用程序。它通常都会包含一个X视窗系统的实现，即一个图形化环境。Linux发行版通常还带有安装程序和附加文档（一般在CD上），帮助你安装自己的Linux系统。   my note: 学习中，我使用的Linux发行版是centos 7，官网是：https://www.centos.org/", 
            "title": "Linux发行版"
        }, 
        {
            "location": "/ch01 入门/#linux_2", 
            "text": "UNIX最初是用C语言编写的，并且UNIX的大多数应用程序也是用C语言编写的，但C语言并不是Linux程序员或UNIX程序员的唯一选择。   my note: 还有许多其他的语言可以选择，不过书中主要讲解的是shell和C语言。", 
            "title": "Linux程序设计"
        }, 
        {
            "location": "/ch01 入门/#linux_3", 
            "text": "Linux应用程序表现为两种特殊类型的文件，可执行文件和脚本文件。可执行文件是计算机可以直接运行的程序，它们相当于Windows中的.exe文件。脚本文件是一组指令的集合，这些指令将由另一个程序（解释器）来执行，相当于Windows的bat文件。  当登陆进Linux系统时，你与一个shell程序进行交互，它像Windows中的命令提示窗口一样运行程序。它在一组指定的目录路径下按照你给出的程序名搜索与之同名的文件。搜索目录路径存储在shell变量PATH里。   my note: PATH变量定义在文件~/.bash_profile中。", 
            "title": "Linux程序"
        }, 
        {
            "location": "/ch01 入门/#_1", 
            "text": "本书的两位作者都喜欢Emacs，并建议读者花一点时间来学习这个功能强大的编辑器。   my note: 不过我使用vim，目前感觉足够了。", 
            "title": "文本编辑器"
        }, 
        {
            "location": "/ch01 入门/#c", 
            "text": "在本书中，我们将使用gcc，这是因为它随Linux的发行版一起提供，并且它支持C语言的ANSI标准语法。  当用gcc命令生成一个可执行程序后（比如gcc -o hello hello.c），可用下面的命令执行此程序：  ./hello  在程序名前加上一个./特别指示shell去执行当前目录下的程序。  如果不使用-o name选项告诉编译器可执行程序的名字，编译器就会把程序放在一个名为a.out的文件里（含义是assembler output，即汇编输出）。", 
            "title": "C语言编译器"
        }, 
        {
            "location": "/ch01 入门/#_2", 
            "text": "对Linux开发人员来说，了解软件工具和开发资源在系统中存放的位置是很重要的。以下几节介绍一些重要的目录和文件。  应用程序  系统为正常使用提供的程序，包括用于程序开发的工具，都可在目录/usr/bin中找到；系统管理员为某个特定的主机或本地网络添加的程序通常可在目录/usr/local/bin或/opt中找到。  我们建议对于系统级的应用程序，你可以将它放在/usr/local目录中来运行和访问所需的文件。对于开发用和个人的应用程序，最好在你的家目录中使用一个文件夹来存放它。   my note: 我写了一个脚本，放在utility目录下，叫findcmd，可以查看这些程序所在的目录。   头文件  用C语言进行程序设计时，你需要用头文件来提供对常量的定义和对系统函数及库函数调用的声明。对C语言来说，这些头文件几乎总是位于/usr/include目录及其子目录中。  在调用C语言编译器时，你可以使用-I标志来包含保存在子目录或非标准位置中的头文件。例如：  $ gcc -I/usr/openwin/include fred.c  它指示编译器不仅在标准位置，也在/usr/openwin/include目录中查找程序fred.c中包含的头文件。  更多细节可以参看使用手册：man gcc  用grep命令来搜索包含某些特定定义和函数原型的头文件是很方便的。比如：  grep EXIT_ /usr/include/*.h  可以查看到退出状态的定义。  库文件  库是一组预先编译好的函数的集合，这些函数都是按照可重用的原则编写的。  标准系统库文件一般存储在/lib和/usr/lib目录中。C语言编译器需要知道要搜索哪些库文件，因为在默认情况下，它只搜索标准C语言库。库文件还必须遵循特定的命名规范并且要在命令行中明确指定。  库文件的名字总是以lib开头，随后的部分指明这是什么库，之后是后缀，给出库文件的类型：  - .a代表传统的静态函数库；\n- .so代表共享函数库。  函数库通常同时以静态库和共享库两种格式存在。可以通过完整的库文件路径名或用-l标志来告诉编译器要搜索的库文件。例如：  $ gcc -o fred fred.c /usr/lib/libm.a\n$ gcc -o fred fred.c -lm  -lm代表标准库目录中名为libm.a的函数库。-lm标志的另一个好处是如果有共享库，编译器会自动选择共享库。  可以通过使用-L标志位编译器增加库的搜索路径。例如：  $ gcc -o x11fred -L/usr/openwin/lib x11fred.c -lX11  静态库  函数库最简单的形式是一组处于“准备好使用”状态的目标文件。程序包含库函数的头文件，编译器和链接器负责将程序代码和函数库结合在一起以组成一个单独的可执行文件。你必须使用-l选项指明除标准C语言运行库外还需使用的库。  静态库也称作归档文件（archive），使用gcc -c命令和ar命令就可以创建静态库。  举个例子：  $ gcc -c bill.c fred.c\n$ ar crv libfoo.a bill.o fred.o\n$ gcc -o program program.o libfoo.a  gcc的-c选项阻止编译器创建一个完整的程序，只生成一份目标文件。  ar命令用来创建归档文件。接着就可以引入此静态库了。  你也可以使用-l选项来访问函数库，但因其未保存在标准位置，所以你必须使用-L选项来告诉编译器在何处可以找到它，如下所示：  $ gcc -o program program.o -L. -lfoo  如有要查看哪些函数被包含在目标文件、函数库或可执行文件里，你可以使用nm命令。当程序被创建时，它只包含函数库中它实际需要的函数。  Windows下有许多相似之处：  |项目|UNIX|Windows|\n|-|-|\n|目标模块|func.o|FUNC.OBJ|\n|静态函数库|lib.a|LIB.LIB|\n|程序|program|PROGRAM.EXE|  共享库  静态库的一个缺点是，当同时运行的程序中都使用了同一个函数库的函数时，内存中就会有同一函数的多份副本。且程序文件中也包含了副本。这将消耗大量宝贵的内存和磁盘空间。  共享库可以克服上述不足。  当一个程序使用共享库时，它的链接方式是这样的：程序本身不再包含函数代码，而是引用运行时可访问的共享代码。  通过这种方法，系统可以只保留共享库的一份副本供许多程序同时使用，并且在磁盘上也仅保存一份。另一个好处是共享库的更新可以独立于依赖它的应用程序，例如，文件/lib/libm.so实际上是/lib/libm.so.N的符号链接，其中N代表主版本号。  对Linux系统来说，负责装载共享库并解析客户程序函数引用的程序是ld.so。用于搜索共享库的额外位置可以在文件/etc/ld.so.conf中配置，如果修改了这个文件，你需要执行命令ldconfig来处理它。  你可以通过运行工具ldd来查看一个程序需要的共享库。如：  $ ldd program  生成共享库的命令可以是：  gcc -shared -o libfunctions.so -fPIC libfunctions.c  链接共享库的方法和静态库一样。但使用前需要配置过一次ldconfig，即此共享库所在的目录已配置在/etc/ld.so.conf中，并执行过一次ldconfig命令。", 
            "title": "开发系统导引"
        }, 
        {
            "location": "/ch01 入门/#_3", 
            "text": "man命令可以用来访问在线手册页。  GNU软件和其他一些自由软件还使用名为info的在线文档系统。你可以通过专用程序info或通过emacs编辑器中的info命令来在线浏览全部的文档。", 
            "title": "获得帮助"
        }, 
        {
            "location": "/ch02 shell程序设计/", 
            "text": "为什么使用shell编程\n\n\n原因之一是，可以快速、简单地完成编程。而且最基本的Linux安装也会提供一个shell。\n\n\nshell非常适合于编写一些执行相对简单的任务的小工具，因为它们强调的是易于配置、易于维护和可移植性，而不是很看重执行效率。\n\n\n使用shell可以使命令按照预定顺序执行。\n\n\n一点哲学\n\n\nUNIX架构非常依赖于代码的高度可重用性。Linux提供了各种各样小巧而简单的工具，比如：\n\n\n$ ls -al | more\n\n\n\n\n通常可以将许多小巧的脚本程序组合起来以创建一个庞大而复杂的程序。\n\n\n什么是shell\n\n\nshell是一个作为用户与Linux系统间接口的程序，它允许用户向操作系统输入需要执行的命令。\n\n\nshell程序和其他程序环绕在Linux内核的四周。\n\n\nshell程序有很多种，在Linux系统中，标准shell是GNU工具集中的bash。使用如下命令查看bash的版本号：\n\n\n$ /bin/bash --version\n\n\n\n\n管道和重定向\n\n\n重定向输出\n\n\n把Linux程序（不仅仅是shell程序）的输出保存到文件：\n\n\n$ ls -l \n lsoutput.txt\n\n\n\n\n需要知道的是：文件描述符0代表一个程序的标准输入，文件描述符1代表标准输出，文件描述符2代表标准错误输出。\n\n\n操作符把标准输出重定向到一个文件。默认情况下，如果该文件已经存在，它的内容将被覆盖。\n\n\n使用\n操作符将输出内容附加到一个文件的尾部。例如：\n\n\n$ ps \n lsoutput.txt\n\n\n\n\n使用\n2\n操作符可以重定向标准错误输出。\n\n\n下面的命令将把标准输出和标准错误输出分别重定向到不同的文件中：\n\n\n$ kill -HUP 1234 \nkillout.txt 2\nkillerr.txt\n\n\n\n\n如果想把两组输出都重定向到一个文件中，可以使用\n操作符来结合两个输出，如：\n\n\n$ kill -HUP 1234 \nkillout.txt 2\n1\n\n\n\n\n这条命令的含义是：将标准输出重定向到文件killout.txt，然后将标准错误输出重定向到与标准输出相同的地方。\n\n\n这样可以丢弃所有的输出信息：\n\n\n$ kill -HUP 1234 \n/dev/null 2\n1\n\n\n\n\n/dev/null是Linux通用的“回收站”。\n\n\n重定向输入\n\n\n使用\n操作符，如：\n\n\n$ more \n killout.txt\n\n\n\n\n但这样做意义不大，因为more命令可以接受文件名作为参数。\n\n\n管道\n\n\n可以用管道操作符|来连接进程。Linux下通过管道连接的进程可以同时运行，并且随着数据流在它们之间的传递可以自动地进行协调。\n\n\n举一个列子，可以使用sort命令对ps命令的输出进行排序：\n\n\n$ ps | sort\n\n\n\n\n如果有一系列的命令需要执行，相应的输出文件是在这一组命令被创建的同时立刻被创建或写入的，所以决不要在命令流中重复使用相同的文件名。比如：\n\n\ncat mydata.txt | sort \n mydata.txt\n\n\n\n\n最终将得到一个空文件，因为在读取文件mydata.txt之前就已经覆盖了这个文件的内容。\n\n\n作为程序设计语言的shell\n\n\n编写shell脚本程序有两种方式：输入一系列命令让shell交互地执行他们；把这些命令保存到一个文件中，然后将该文件作为一个程序来调用。\n\n\n交互式程序\n\n\n即在命令行上直接输入shell脚本。当shell期待进一步的输入时，正常的$shell提示符将改变为\n提示符，由shell来判断何时输入完毕并立即执行脚本程序。\n\n\n比如：\n\n\n$ for file in *\n\n do\n\n if grep -l POSIX $file\n\n then\n\n more file\n\n fi\n\n done\n\n\n\n\ngrep -l找到当前路径下包含POSIX字符串的文件，more命令将文件的内容显示在屏幕上。\n\n\n扩展的花括号{}允许将任意字符串放在一个集合中，以供shell进行扩展，比如：\n\n\n$ ls my_{finger,toe}s\n\n\n\n\n将列出文件my_fingers和my_toes。\n\n\n创建脚本\n\n\n一个简单的模板（见first.sh）：\n\n\n#! /bin/bash\n\n# filename: ...\n# description: ...\n\nshell语句\n\nexit 0\n\n\n\n\n程序中的注释以#号开始，一直持续到该行的结束。\n\n\n#! /bin/bash\n是一种特殊形式的注释，#!字符告诉系统紧跟在它后面的那个参数是用来执行本文件的程序（使用绝对路径）。\n\n\n因为脚本程序本质上被看作是shell的标准输入，所以它可以包含任何能够通过你的PATH环境变量引用到的Linux命令。\n\n\nexit命令的作用是确保脚本程序能够返回一个有意义的退出码，表示此脚本是否执行成功。在shell程序设计里，0表示成功。\n\n\nLinux很少利用文件扩展名来决定文件的类型，可以为脚本使用.sh或其他扩展名，但shell并不关心这一点。大多数预安装的脚本程序并没有使用任何文件扩展名。检查文件是否是脚本程序的最好方法是使用file命令，如：\nfile first.sh\n。\n\n\n把脚本设置为可执行\n\n\n运行脚本程序的方法是：\n\n\n$ sh fist.sh\n\n\n\n\n也可以只输入脚本名字就运行程序，这需要给脚本文件加上可执行权限：\n\n\n$ chmod +x first.sh\n$ ./fist.sh\n\n\n\n\nshell的语法\n\n\n变量\n\n\n在shell里，使用变量之前无需为它们做出声明，通过使用它们（比如给它们赋初值时）来创建它们。\n\n\n默认情况下，所有的变量都被看作字符串并以字符串来存储。shell和一些工具程序会在需要时把数值型字符串转换为对应的数值。\n\n\n变量区分大小写。\n\n\n在变量名前加一个$符号来访问它的内容。比如：\n\n\n$ salutation=Hello\n$ echo $salutation\n\n\n\n\n如果字符串里包含空格，就必须用引号把它们括起来；等号两边不能有空格。\n\n\n使用read命令将用户的输入赋值给一个变量，通常情况下，在用户按下回车键时，read命令结束。如：\n\n\n$ read a\nhello world\n$ echo $a\nhello world\n\n\n\n\n使用引号\n\n\n一般情况下，脚本文件的参数以空白字符分隔，如果想在一个参数中包含空白字符，必须给参数加上引号。\n\n\n如果把一个$变量表达式放在双引号中，程序执行到这一行时就会把变量替换为它的值；如果把它放在单引号中，就不会发生替换现象。在$符前面加上\\字符以取消它的特殊含义。\n\n\n环境变量\n\n\n当一个shell脚本程序开始执行时，一些变量会根据环境设置中的值进行初始化。这些变量通常用大写字母做名字，用户在脚本里定义的变量通常用小写字母做名字。\n\n\n主要的环境变量有：\n\n\n\n\n\n\n\n\n环境变量\n\n\n说明\n\n\n\n\n\n\n\n\n\n\n$PATH\n\n\n搜索命令的目录列表\n\n\n\n\n\n\n$HOME\n\n\n用户宿主目录\n\n\n\n\n\n\n$PS1\n\n\n命令提示符\n\n\n\n\n\n\n$PS2\n\n\n二级提示符，一般是\n\n\n\n\n\n\n$IFS\n\n\n输入域分隔符，比如空格符，换行符\n\n\n\n\n\n\n$0\n\n\nshell脚本的名字\n\n\n\n\n\n\n$#\n\n\n传递给脚本的参数个数\n\n\n\n\n\n\n$$\n\n\n脚本的进程ID，可用于生成一个唯一的文件\n\n\n\n\n\n\n\n\n参数变量\n\n\n如果脚本程序在调用时带有参数，一些额外的变量就会被创建：\n\n\n\n\n\n\n\n\n参数变量\n\n\n说明\n\n\n\n\n\n\n\n\n\n\n$*\n, \n$@\n\n\n列出所有的参数，更推荐使用\n$@\n，因为\n$*\n会根据$IFS进行分隔\n\n\n\n\n\n\n$1\n, \n$2\n, ...\n\n\n第n个参数\n\n\n\n\n\n\n\n\n条件\n\n\n一个shell脚本能够对任何可以从命令行上调用的命令的退出码进行测试。\n\n\ntest或[命令\n\n\n在实际工作中，大多数脚本程序都会广泛使用shell的布尔判断命令test或[。test命令的退出码（表明条件是否满足）决定是否需要执行后面的条件代码。\n\n\n为了可读性，当使用[命令时，还可以使用符号]来结尾。\n\n\n一个用户检查文件是否存在的例子：\n\n\nif test -f fred.c\nthen\n...\nfi\n\n\n\n\n或者写成：\n\n\nif [ -f fred.c ]\nthen\n...\nfi\n\n\n\n\ntest命令可以使用的条件类型可以归为3类：字符串比较、算术比较和文件有关的条件测试。\n\n\n一些条件如下表：\n\n\n\n\n\n\n\n\n字符串比较\n\n\n结果\n\n\n\n\n\n\n\n\n\n\nstring1 = string2\n\n\n如果字符串相等，返回真\n\n\n\n\n\n\nstring1 != string2\n\n\n如果字符串不相等，返回真\n\n\n\n\n\n\n-n string\n\n\n如果字符串不为空则返回真\n\n\n\n\n\n\n-z string\n\n\n如果字符串为空则返回真\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n算术比较\n\n\n结果\n\n\n\n\n\n\n\n\n\n\nexpr1 -eq expr2\n\n\n两个表达式相等，返回真\n\n\n\n\n\n\nexpr1 -nq expr2\n\n\n两个表达式不相等。返回真\n\n\n\n\n\n\nexpr1 -gt expr2\n\n\n表达式1大于表达式2，返回真\n\n\n\n\n\n\nexpr1 -ge expr2\n\n\n表达式1大于等于表达式2，返回真\n\n\n\n\n\n\nexpr1 -lt expr2\n\n\n表达式1小于表达式2，返回真\n\n\n\n\n\n\nexpr1 -le expr2\n\n\n表达式1小于等于表达式2，返回真\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n文件条件测试\n\n\n结果\n\n\n\n\n\n\n\n\n\n\n-d file\n\n\n如果file是目录，则为真\n\n\n\n\n\n\n-f file\n\n\n如果file存在，则为真\n\n\n\n\n\n\n-s file\n\n\n如果file大小不为0，则为真\n\n\n\n\n\n\n\n\ntest命令是bash的内置命令，使用help test命令可以获得test命令的详细信息（或者man test）。\n\n\n控制结构\n\n\nif语句\n\n\n它对某个命令的执行结果进行测试，然后根据测试结果有条件地执行一组语句。如：\n\n\nif condition\nthen\n    statements\nelif condition\nthen\n    statements\nelse\n    statements\nfi\n\n\n\n\nfor语句\n\n\n可以利用for结构来循环处理一组值，这组值可以是任意字符串的集合。它们可以在程序里被列出，更常见的做法是使用shell的文件名扩展结果。\n\n\n简单语法是：\n\n\nfor variable in values\ndo\n    statements\ndone\n\n\n\n\nwhile语句\n\n\n如果需要重复执行一个命令序列，但事先又不知道这个命令序列应该执行的次数，你通常会使用一个while循环，它的语法如下：\n\n\nwhile condition\ndo\n    statements\ndone\n\n\n\n\nuntil语句\n\n\n语法如下：\n\n\nuntil condition\ndo\n    statements\ndone\n\n\n\n\n循环将反复执行，直到条件为真。\n\n\ncase语句\n\n\n语法如下：\n\n\ncase variable in\n    partion [ | pattern] ...) statements;;\n    partion [ | pattern] ...) statements;;\n    ...\nesac\n\n\n\n\ncase结构允许你通过一种比较复杂的方式将变量的内容和模式进行匹配，然后再根据匹配的模式去执行不同的代码。\n\n\n每个模式行都以双分号结尾。\n\n\ncase将使用第一个匹配的模式，即使后续的模式有更加精确的匹配也是如此。\n\n\n命令列表\n\n\nAND和OR专门用于处理命令列表。\n\n\n- AND列表\n\n\nAND列表结构允许你按照这样的方式执行一系列命令，只有在前面的所有命令执行成功的情况下，才执行后一条命令：\n\n\nstatement1 \n statement2 \n statement3\n\n\n\n\n只有列表中的所有命令都执行成功时，才算它执行成功，否则就算它失败。\n\n\n- OR列表\n\n\nOR列表结构允许我们执行一系列命令直到有一条命令成功为止，其后的命令将不再被执行：\n\n\nstatement1 || statement2 || statement3\n\n\n\n\n这些列表类型结构的执行方式被称为\n短路求值（short circuit evaluation）\n。\n\n\n还可以把这两种结构结合在一起，比如：\n\n\n[ -f file ] \n cmd1 || cmd2\n\n\n\n\n上面的语句中，如果file存在，则执行cmd1，否则执行cmd2。还可以使用括号来强制求值的顺序。\n\n\n语句块\n\n\n如果想在某些只允许使用单个语句的地方使用多条语句，你可以把它们括在花括号中来构造一个语句块。\n\n\n函数\n\n\n定义一个函数的语法如下：\n\n\nfunction_name() {\n    statements\n}\n\n\n\n\n当程序遇到函数定义时，它会记住此函数名，然后从}字符之后的位置继续执行。当执行到function_name时，shell就知道应该去执行刚才定义的函数了。这个函数执行完毕以后，执行过程会返回到调用函数那条语句的后面继续执行。\n\n\n当一个函数被调用时，脚本程序的位置参数（$*, $@, $#, $1, $2）等会被替换为函数的参数，这也是读取传递给函数的参数的办法。当函数执行完毕后，这些参数会恢复为它们先前的值。\n\n\n可以通过return命令让函数返回数字值。如果想让函数返回字符串，可以让函数将字符串保存在一个变量中，该变量然后可以在函数结束之后使用。或者可以echo一个字符串并捕获其结果。如：\n\n\nfoo() { echo JAY; }\n...\nresult = \n$(foo)\n\n\n\n\n\n如果在函数里没有使用return指定一个返回值，函数返回的就是执行的最后一条命令的退出码。\n\n\n可以使用local关键字在shell函数中声明局部变量，使其仅在函数内有效。函数可以访问全局作用范围内的其他shell变量。\n\n\nhere文档\n\n\n在shell脚本程序中向一条命令传递输入的一种特殊方法是使用here文档。它允许一条命令在获得输入数据时就好像是在读取一个文件或键盘一样，而实际上是从脚本程序中得到输入数据。\n\n\n更多见代码案例以及书本。", 
            "title": "ch02 shell程序设计"
        }, 
        {
            "location": "/ch02 shell程序设计/#shell", 
            "text": "原因之一是，可以快速、简单地完成编程。而且最基本的Linux安装也会提供一个shell。  shell非常适合于编写一些执行相对简单的任务的小工具，因为它们强调的是易于配置、易于维护和可移植性，而不是很看重执行效率。  使用shell可以使命令按照预定顺序执行。", 
            "title": "为什么使用shell编程"
        }, 
        {
            "location": "/ch02 shell程序设计/#_1", 
            "text": "UNIX架构非常依赖于代码的高度可重用性。Linux提供了各种各样小巧而简单的工具，比如：  $ ls -al | more  通常可以将许多小巧的脚本程序组合起来以创建一个庞大而复杂的程序。", 
            "title": "一点哲学"
        }, 
        {
            "location": "/ch02 shell程序设计/#shell_1", 
            "text": "shell是一个作为用户与Linux系统间接口的程序，它允许用户向操作系统输入需要执行的命令。  shell程序和其他程序环绕在Linux内核的四周。  shell程序有很多种，在Linux系统中，标准shell是GNU工具集中的bash。使用如下命令查看bash的版本号：  $ /bin/bash --version", 
            "title": "什么是shell"
        }, 
        {
            "location": "/ch02 shell程序设计/#_2", 
            "text": "", 
            "title": "管道和重定向"
        }, 
        {
            "location": "/ch02 shell程序设计/#_3", 
            "text": "把Linux程序（不仅仅是shell程序）的输出保存到文件：  $ ls -l   lsoutput.txt  需要知道的是：文件描述符0代表一个程序的标准输入，文件描述符1代表标准输出，文件描述符2代表标准错误输出。  操作符把标准输出重定向到一个文件。默认情况下，如果该文件已经存在，它的内容将被覆盖。  使用 操作符将输出内容附加到一个文件的尾部。例如：  $ ps   lsoutput.txt  使用 2 操作符可以重定向标准错误输出。  下面的命令将把标准输出和标准错误输出分别重定向到不同的文件中：  $ kill -HUP 1234  killout.txt 2 killerr.txt  如果想把两组输出都重定向到一个文件中，可以使用 操作符来结合两个输出，如：  $ kill -HUP 1234  killout.txt 2 1  这条命令的含义是：将标准输出重定向到文件killout.txt，然后将标准错误输出重定向到与标准输出相同的地方。  这样可以丢弃所有的输出信息：  $ kill -HUP 1234  /dev/null 2 1  /dev/null是Linux通用的“回收站”。", 
            "title": "重定向输出"
        }, 
        {
            "location": "/ch02 shell程序设计/#_4", 
            "text": "使用 操作符，如：  $ more   killout.txt  但这样做意义不大，因为more命令可以接受文件名作为参数。", 
            "title": "重定向输入"
        }, 
        {
            "location": "/ch02 shell程序设计/#_5", 
            "text": "可以用管道操作符|来连接进程。Linux下通过管道连接的进程可以同时运行，并且随着数据流在它们之间的传递可以自动地进行协调。  举一个列子，可以使用sort命令对ps命令的输出进行排序：  $ ps | sort  如果有一系列的命令需要执行，相应的输出文件是在这一组命令被创建的同时立刻被创建或写入的，所以决不要在命令流中重复使用相同的文件名。比如：  cat mydata.txt | sort   mydata.txt  最终将得到一个空文件，因为在读取文件mydata.txt之前就已经覆盖了这个文件的内容。", 
            "title": "管道"
        }, 
        {
            "location": "/ch02 shell程序设计/#shell_2", 
            "text": "编写shell脚本程序有两种方式：输入一系列命令让shell交互地执行他们；把这些命令保存到一个文件中，然后将该文件作为一个程序来调用。", 
            "title": "作为程序设计语言的shell"
        }, 
        {
            "location": "/ch02 shell程序设计/#_6", 
            "text": "即在命令行上直接输入shell脚本。当shell期待进一步的输入时，正常的$shell提示符将改变为 提示符，由shell来判断何时输入完毕并立即执行脚本程序。  比如：  $ for file in *  do  if grep -l POSIX $file  then  more file  fi  done  grep -l找到当前路径下包含POSIX字符串的文件，more命令将文件的内容显示在屏幕上。  扩展的花括号{}允许将任意字符串放在一个集合中，以供shell进行扩展，比如：  $ ls my_{finger,toe}s  将列出文件my_fingers和my_toes。", 
            "title": "交互式程序"
        }, 
        {
            "location": "/ch02 shell程序设计/#_7", 
            "text": "一个简单的模板（见first.sh）：  #! /bin/bash\n\n# filename: ...\n# description: ...\n\nshell语句\n\nexit 0  程序中的注释以#号开始，一直持续到该行的结束。  #! /bin/bash 是一种特殊形式的注释，#!字符告诉系统紧跟在它后面的那个参数是用来执行本文件的程序（使用绝对路径）。  因为脚本程序本质上被看作是shell的标准输入，所以它可以包含任何能够通过你的PATH环境变量引用到的Linux命令。  exit命令的作用是确保脚本程序能够返回一个有意义的退出码，表示此脚本是否执行成功。在shell程序设计里，0表示成功。  Linux很少利用文件扩展名来决定文件的类型，可以为脚本使用.sh或其他扩展名，但shell并不关心这一点。大多数预安装的脚本程序并没有使用任何文件扩展名。检查文件是否是脚本程序的最好方法是使用file命令，如： file first.sh 。", 
            "title": "创建脚本"
        }, 
        {
            "location": "/ch02 shell程序设计/#_8", 
            "text": "运行脚本程序的方法是：  $ sh fist.sh  也可以只输入脚本名字就运行程序，这需要给脚本文件加上可执行权限：  $ chmod +x first.sh\n$ ./fist.sh", 
            "title": "把脚本设置为可执行"
        }, 
        {
            "location": "/ch02 shell程序设计/#shell_3", 
            "text": "", 
            "title": "shell的语法"
        }, 
        {
            "location": "/ch02 shell程序设计/#_9", 
            "text": "在shell里，使用变量之前无需为它们做出声明，通过使用它们（比如给它们赋初值时）来创建它们。  默认情况下，所有的变量都被看作字符串并以字符串来存储。shell和一些工具程序会在需要时把数值型字符串转换为对应的数值。  变量区分大小写。  在变量名前加一个$符号来访问它的内容。比如：  $ salutation=Hello\n$ echo $salutation  如果字符串里包含空格，就必须用引号把它们括起来；等号两边不能有空格。  使用read命令将用户的输入赋值给一个变量，通常情况下，在用户按下回车键时，read命令结束。如：  $ read a\nhello world\n$ echo $a\nhello world  使用引号  一般情况下，脚本文件的参数以空白字符分隔，如果想在一个参数中包含空白字符，必须给参数加上引号。  如果把一个$变量表达式放在双引号中，程序执行到这一行时就会把变量替换为它的值；如果把它放在单引号中，就不会发生替换现象。在$符前面加上\\字符以取消它的特殊含义。  环境变量  当一个shell脚本程序开始执行时，一些变量会根据环境设置中的值进行初始化。这些变量通常用大写字母做名字，用户在脚本里定义的变量通常用小写字母做名字。  主要的环境变量有：     环境变量  说明      $PATH  搜索命令的目录列表    $HOME  用户宿主目录    $PS1  命令提示符    $PS2  二级提示符，一般是    $IFS  输入域分隔符，比如空格符，换行符    $0  shell脚本的名字    $#  传递给脚本的参数个数    $$  脚本的进程ID，可用于生成一个唯一的文件     参数变量  如果脚本程序在调用时带有参数，一些额外的变量就会被创建：     参数变量  说明      $* ,  $@  列出所有的参数，更推荐使用 $@ ，因为 $* 会根据$IFS进行分隔    $1 ,  $2 , ...  第n个参数", 
            "title": "变量"
        }, 
        {
            "location": "/ch02 shell程序设计/#_10", 
            "text": "一个shell脚本能够对任何可以从命令行上调用的命令的退出码进行测试。  test或[命令  在实际工作中，大多数脚本程序都会广泛使用shell的布尔判断命令test或[。test命令的退出码（表明条件是否满足）决定是否需要执行后面的条件代码。  为了可读性，当使用[命令时，还可以使用符号]来结尾。  一个用户检查文件是否存在的例子：  if test -f fred.c\nthen\n...\nfi  或者写成：  if [ -f fred.c ]\nthen\n...\nfi  test命令可以使用的条件类型可以归为3类：字符串比较、算术比较和文件有关的条件测试。  一些条件如下表：     字符串比较  结果      string1 = string2  如果字符串相等，返回真    string1 != string2  如果字符串不相等，返回真    -n string  如果字符串不为空则返回真    -z string  如果字符串为空则返回真        算术比较  结果      expr1 -eq expr2  两个表达式相等，返回真    expr1 -nq expr2  两个表达式不相等。返回真    expr1 -gt expr2  表达式1大于表达式2，返回真    expr1 -ge expr2  表达式1大于等于表达式2，返回真    expr1 -lt expr2  表达式1小于表达式2，返回真    expr1 -le expr2  表达式1小于等于表达式2，返回真        文件条件测试  结果      -d file  如果file是目录，则为真    -f file  如果file存在，则为真    -s file  如果file大小不为0，则为真     test命令是bash的内置命令，使用help test命令可以获得test命令的详细信息（或者man test）。", 
            "title": "条件"
        }, 
        {
            "location": "/ch02 shell程序设计/#_11", 
            "text": "if语句  它对某个命令的执行结果进行测试，然后根据测试结果有条件地执行一组语句。如：  if condition\nthen\n    statements\nelif condition\nthen\n    statements\nelse\n    statements\nfi  for语句  可以利用for结构来循环处理一组值，这组值可以是任意字符串的集合。它们可以在程序里被列出，更常见的做法是使用shell的文件名扩展结果。  简单语法是：  for variable in values\ndo\n    statements\ndone  while语句  如果需要重复执行一个命令序列，但事先又不知道这个命令序列应该执行的次数，你通常会使用一个while循环，它的语法如下：  while condition\ndo\n    statements\ndone  until语句  语法如下：  until condition\ndo\n    statements\ndone  循环将反复执行，直到条件为真。  case语句  语法如下：  case variable in\n    partion [ | pattern] ...) statements;;\n    partion [ | pattern] ...) statements;;\n    ...\nesac  case结构允许你通过一种比较复杂的方式将变量的内容和模式进行匹配，然后再根据匹配的模式去执行不同的代码。  每个模式行都以双分号结尾。  case将使用第一个匹配的模式，即使后续的模式有更加精确的匹配也是如此。  命令列表  AND和OR专门用于处理命令列表。  - AND列表  AND列表结构允许你按照这样的方式执行一系列命令，只有在前面的所有命令执行成功的情况下，才执行后一条命令：  statement1   statement2   statement3  只有列表中的所有命令都执行成功时，才算它执行成功，否则就算它失败。  - OR列表  OR列表结构允许我们执行一系列命令直到有一条命令成功为止，其后的命令将不再被执行：  statement1 || statement2 || statement3  这些列表类型结构的执行方式被称为 短路求值（short circuit evaluation） 。  还可以把这两种结构结合在一起，比如：  [ -f file ]   cmd1 || cmd2  上面的语句中，如果file存在，则执行cmd1，否则执行cmd2。还可以使用括号来强制求值的顺序。  语句块  如果想在某些只允许使用单个语句的地方使用多条语句，你可以把它们括在花括号中来构造一个语句块。", 
            "title": "控制结构"
        }, 
        {
            "location": "/ch02 shell程序设计/#_12", 
            "text": "定义一个函数的语法如下：  function_name() {\n    statements\n}  当程序遇到函数定义时，它会记住此函数名，然后从}字符之后的位置继续执行。当执行到function_name时，shell就知道应该去执行刚才定义的函数了。这个函数执行完毕以后，执行过程会返回到调用函数那条语句的后面继续执行。  当一个函数被调用时，脚本程序的位置参数（$*, $@, $#, $1, $2）等会被替换为函数的参数，这也是读取传递给函数的参数的办法。当函数执行完毕后，这些参数会恢复为它们先前的值。  可以通过return命令让函数返回数字值。如果想让函数返回字符串，可以让函数将字符串保存在一个变量中，该变量然后可以在函数结束之后使用。或者可以echo一个字符串并捕获其结果。如：  foo() { echo JAY; }\n...\nresult =  $(foo)   如果在函数里没有使用return指定一个返回值，函数返回的就是执行的最后一条命令的退出码。  可以使用local关键字在shell函数中声明局部变量，使其仅在函数内有效。函数可以访问全局作用范围内的其他shell变量。", 
            "title": "函数"
        }, 
        {
            "location": "/ch02 shell程序设计/#here", 
            "text": "在shell脚本程序中向一条命令传递输入的一种特殊方法是使用here文档。它允许一条命令在获得输入数据时就好像是在读取一个文件或键盘一样，而实际上是从脚本程序中得到输入数据。  更多见代码案例以及书本。", 
            "title": "here文档"
        }, 
        {
            "location": "/ch03 文件操作_1/", 
            "text": "Linux文件结构\n\n\nLinux环境中的文件具有特别重要的意义，因为它们为操作系统服务和设备提供了一个简单而一致的接口。在Linux中，\n一切（或几乎一切）都是文件\n。\n\n\n这就意味着，通常程序完全可以像使用文件那样使用磁盘文件、串行口、打印机和其他设备。大多数情况下，你只需要使用5个基本的函数——open、close、read、write和ioctl。\n\n\n目录是一种特殊类型的文件，在现代的UNIX（包括Linux）版本中，即使是超级用户可能也不再被允许直接对目录进行写操作了。所有用户通常使用上层的opendir/readdir接口来读取目录。\n\n\n目录\n\n\n文件，除了本身包含的内容以外，它还会有一个名字和一些属性。这些属性被保存在文件的inode（节点）中，它是文件系统中的一个特殊的数据块，它同时还包含文件的长度和文件在磁盘上的存放位置。系统使用的是文件的inode编号，目录结构为文件命名仅仅是为了便于人们使用。\n\n\n目录是用于保存其他文件的节点号和名字的文件。目录文件中的每个数据项都是指向某个文件节点的链接，删除文件名就等于删除与之对应的链接（文件的节点号可以通过ls -i命令查看）。你可以通过使用ln命令在不同的目录中创建指向同一个文件的链接。\n\n\n\n\n【my note】\n\n\n假如有一个文件名为foo.txt，然后执行：\n\n\n$ ln foo2.txt foo.txt # 如此一来，foo2.txt和foo.txt将是同一个文件\n$ ls -il foo*\n\n\n\n\n可以看到，这两个文件的节点号是一致的，且链接数都是2。\n\n\n\n\n删除一个文件时，实质上是删除了该文件对应的目录项，同时指向该文件的链接数减1。如果指向某个文件的链接数（即ls -l命令输出中跟在访问权限后面的那个数字）变为0，就表示该节点以及其指向的数据不再被使用，磁盘上的相应位置就会被标记为可用空间。\n\n\n文件被安排在目录中，目录中可能还包含子目录。这就构成了文件系统层次结构。如图：\n\n\n\n\n文件和设备\n\n\n硬件设备在Linux中通常也被表示（映射）为文件。例如，作为超级用户，你可以使用如下命令将IDE CD-ROM驱动器挂载为一个文件：\n\n\n# mount -t iso9660 /dev/hdc /mnt/cdrom\n# cd /mnt/cdrom\n\n\n\n\n这个命令将CD-ROM设备中的当前内容挂载为/mnt/cdrom目录下的文件结构。然后，你就可以像往常一样浏览CD-ROM的目录，只不过其内容是只读的。\n\n\n\n\n【my note】\n\n\n我使用的是安装在虚拟机里的CentOS 7，挂载的方法是：先打开虚拟机设置-\n存储，把iso镜像添加成IDE，然后输入命令：\n\n\n# mkdir -p /mnt/cdrom\n# mount -t iso9660 /dev/cdrom /mnt/cdrom\n\n\n\n\n卸载的命令是：\n\n\n# umount /mnt/cdrom\n\n\n\n\n\n\nUNIX和Linux众比较重要的设备文件有3个：/dev/console、/dev/tty和/dev/null\n\n\n\n\nmy note: 书上讲的概念性比较强，读到此处时还没能完全理解（除了/dev/null比较好理解），所以还是看书吧。\n\n\n\n\n设备被分为字符设备和块设备，两者的区别在于访问设备时是否需要一次读写一整块。比如硬盘就是一个块设备。\n\n\n系统调用和设备驱动程序\n\n\n系统调用函数，由Linux直接提供，它们是通向操作系统本身的接口。\n\n\n操作系统的核心部分，即内核，是一组设备驱动程序。它们是一组对系统硬件进行控制的底层接口。\n\n\n下面是用于访问设备驱动程序的底层函数（系统调用）。\n\n\n\n\n\n\nopen：打开文件或设备。\n\n\n\n\n\n\nread：从打开的文件或设备里读数据。\n\n\n\n\n\n\nwrite：向文件或设备写数据。\n\n\n\n\n\n\nclose：关闭文件或设备。\n\n\n\n\n\n\nioctl：把控制信息传递给设备驱动程序。\n\n\n\n\n\n\n系统调用ioctl用于提供一些与特定硬件设备有关的必要控制（与正常的输入输出相反），所以它的用法随设备的不同而不同。\n\n\n系统调用的文档一般放在手册页的第二节。\n\n\n库函数\n\n\n针对输入输出操作直接使用底层系统调用的一个问题是它们的效率非常低。为什么呢？\n\n\n\n\n\n\n使用系统调用会影响系统的性能。与函数调用相比，系统调用的开销要大些，因为在执行系统调用时，Linux必须从运行用户代码切换到执行内核代码，然后再返回用户代码。\n\n\n\n\n\n\n硬件会限制对底层系统调用一次所能读写的数据块大小。\n\n\n\n\n\n\n为了给设备和磁盘文件提供更高层的接口，Linux发行版提供了一系列的标准库函数。你可以高效地写任意长度的数据块，库函数则在数据满足数据块长度要求时安排执行底层系统调用。这就极大降低了系统调用的开销。\n\n\n库函数的文档一般放在手册页的第三节。\n\n\n下图显示了Linux系统中各种文件函数与用户、设备驱动程序、内核和硬件之间的关系。", 
            "title": "文件操作1"
        }, 
        {
            "location": "/ch03 文件操作_1/#linux", 
            "text": "Linux环境中的文件具有特别重要的意义，因为它们为操作系统服务和设备提供了一个简单而一致的接口。在Linux中， 一切（或几乎一切）都是文件 。  这就意味着，通常程序完全可以像使用文件那样使用磁盘文件、串行口、打印机和其他设备。大多数情况下，你只需要使用5个基本的函数——open、close、read、write和ioctl。  目录是一种特殊类型的文件，在现代的UNIX（包括Linux）版本中，即使是超级用户可能也不再被允许直接对目录进行写操作了。所有用户通常使用上层的opendir/readdir接口来读取目录。", 
            "title": "Linux文件结构"
        }, 
        {
            "location": "/ch03 文件操作_1/#_1", 
            "text": "文件，除了本身包含的内容以外，它还会有一个名字和一些属性。这些属性被保存在文件的inode（节点）中，它是文件系统中的一个特殊的数据块，它同时还包含文件的长度和文件在磁盘上的存放位置。系统使用的是文件的inode编号，目录结构为文件命名仅仅是为了便于人们使用。  目录是用于保存其他文件的节点号和名字的文件。目录文件中的每个数据项都是指向某个文件节点的链接，删除文件名就等于删除与之对应的链接（文件的节点号可以通过ls -i命令查看）。你可以通过使用ln命令在不同的目录中创建指向同一个文件的链接。   【my note】  假如有一个文件名为foo.txt，然后执行：  $ ln foo2.txt foo.txt # 如此一来，foo2.txt和foo.txt将是同一个文件\n$ ls -il foo*  可以看到，这两个文件的节点号是一致的，且链接数都是2。   删除一个文件时，实质上是删除了该文件对应的目录项，同时指向该文件的链接数减1。如果指向某个文件的链接数（即ls -l命令输出中跟在访问权限后面的那个数字）变为0，就表示该节点以及其指向的数据不再被使用，磁盘上的相应位置就会被标记为可用空间。  文件被安排在目录中，目录中可能还包含子目录。这就构成了文件系统层次结构。如图：", 
            "title": "目录"
        }, 
        {
            "location": "/ch03 文件操作_1/#_2", 
            "text": "硬件设备在Linux中通常也被表示（映射）为文件。例如，作为超级用户，你可以使用如下命令将IDE CD-ROM驱动器挂载为一个文件：  # mount -t iso9660 /dev/hdc /mnt/cdrom\n# cd /mnt/cdrom  这个命令将CD-ROM设备中的当前内容挂载为/mnt/cdrom目录下的文件结构。然后，你就可以像往常一样浏览CD-ROM的目录，只不过其内容是只读的。   【my note】  我使用的是安装在虚拟机里的CentOS 7，挂载的方法是：先打开虚拟机设置- 存储，把iso镜像添加成IDE，然后输入命令：  # mkdir -p /mnt/cdrom\n# mount -t iso9660 /dev/cdrom /mnt/cdrom  卸载的命令是：  # umount /mnt/cdrom   UNIX和Linux众比较重要的设备文件有3个：/dev/console、/dev/tty和/dev/null   my note: 书上讲的概念性比较强，读到此处时还没能完全理解（除了/dev/null比较好理解），所以还是看书吧。   设备被分为字符设备和块设备，两者的区别在于访问设备时是否需要一次读写一整块。比如硬盘就是一个块设备。", 
            "title": "文件和设备"
        }, 
        {
            "location": "/ch03 文件操作_1/#_3", 
            "text": "系统调用函数，由Linux直接提供，它们是通向操作系统本身的接口。  操作系统的核心部分，即内核，是一组设备驱动程序。它们是一组对系统硬件进行控制的底层接口。  下面是用于访问设备驱动程序的底层函数（系统调用）。    open：打开文件或设备。    read：从打开的文件或设备里读数据。    write：向文件或设备写数据。    close：关闭文件或设备。    ioctl：把控制信息传递给设备驱动程序。    系统调用ioctl用于提供一些与特定硬件设备有关的必要控制（与正常的输入输出相反），所以它的用法随设备的不同而不同。  系统调用的文档一般放在手册页的第二节。", 
            "title": "系统调用和设备驱动程序"
        }, 
        {
            "location": "/ch03 文件操作_1/#_4", 
            "text": "针对输入输出操作直接使用底层系统调用的一个问题是它们的效率非常低。为什么呢？    使用系统调用会影响系统的性能。与函数调用相比，系统调用的开销要大些，因为在执行系统调用时，Linux必须从运行用户代码切换到执行内核代码，然后再返回用户代码。    硬件会限制对底层系统调用一次所能读写的数据块大小。    为了给设备和磁盘文件提供更高层的接口，Linux发行版提供了一系列的标准库函数。你可以高效地写任意长度的数据块，库函数则在数据满足数据块长度要求时安排执行底层系统调用。这就极大降低了系统调用的开销。  库函数的文档一般放在手册页的第三节。  下图显示了Linux系统中各种文件函数与用户、设备驱动程序、内核和硬件之间的关系。", 
            "title": "库函数"
        }, 
        {
            "location": "/ch03 文件操作_2/", 
            "text": "底层文件访问\n\n\n每个运行中的程序被称为\n进程\n（process），它有一些与之关联的文件描述符。这是一些小值整数，你可以通过它们访问文件或设备。当一个程序开始运行时，它一般会有3个已经打开的文件描述符：\n\n\n- 0：标准输入\n\n\n- 1：标准输出\n\n\n- 2：标准错误\n\n\n你可以通过系统调用open把其他文件描述符与文件和设备相关联。\n\n\n\n\nmy note: 以下系统调用的函数原型用的是我使用的CentOS 7的手册页中的声明，和书中的声明略有不同。\n\n\n\n\nwrite系统调用\n\n\n系统调用write的作用是把缓冲区buf的前nbytes个字节写入与文件描述符fildes关联的文件中。它返回实际写入的字节数。如果文件描述符有错或者底层设备驱动程序对数据块长度比较敏感，该返回值可能会小于nbytes。如果这个函数返回0，就表示未写入任何数据；如果返回-1，就表示出现了错误，错误代码保存到全局变量errno里。\n\n\n#include \nunistd.h\n\n\nssize_t write(int fd, const void *buf, size_t count);\n\n\n\n\n当程序退出运行时，所有已经打开的文件描述符都会自动关闭，所以你不需要明确地关闭它们。但处理被缓冲的输出时，情况就不一样了。\n\n\nread系统调用\n\n\n系统调用read的作用是：从与文件描述符fildes相关联的文件里读入nbytes个字节的数据，并把它们放到数据区buf中。它返回实际读入的字节数，这可能会小于请求的字节数。如果read调用返回0，就表示未读入任何数据，已达到文件尾。如果返回-1，就表示出现了错误。\n\n\n#include \nunistd.h\n\n\nssize_t read(int fd, void *buf, size_t count);\n\n\n\n\nopen系统调用\n\n\n为了创建一个新的文件描述符，你需要使用系统调用open。\n\n\n#include \nsys/types.h\n\n#include \nsys/stat.h\n\n#include \nfcntl.h\n\n\nint open(const char *pathname, int flags);\nint open(const char *pathname, int flags, mode_t mode);\n\nint creat(const char *pathname, mode_t mode);\n\n\n\n\n简单的说，open建立了一条到文件或设备的访问路径。如果调用成功，它将返回一个可以被read、write和其他系统调用使用的文件描述符。这个文件描述符是唯一的，它不会与任何其他运行中的进程共享。\n\n\noflags参数用于指定打开文件所采取的动作。它是通过命令文件访问模式与其他可选模式相结合的方式来指定的。open调用必须指定表3-1中所示的文件访问模式之一。\n\n\n\n\nopen调用还可以在oflags参数中包括下列可选模式的组合（用“按位或”操作）。\n\n\n- O_APPEND：把写入的数据追加在文件的末尾。\n- O_TRUNC：把文件的长度设置为0，丢弃已有的内容。\n- O_CREAT：如果需要，就按照参数mode中给出的访问模式创建文件。\n- O_EXCL：与O_CREAT一起使用，确保调用者创建出文件。Open调用是一个原子操作，也就是说，它只执行一次函数调用。使用这个可选模式可以防止两个程序同时创建同一个文件。如果文件已存在，open调用将失败。\n\n\nopen调用失败返回-1并设置errno。新的文件描述符总是使用未用描述符的最小值。\n\n\nPOSIX规范还标准化了一个creat调用，它不仅会像预期那样创建文件，还会打开文件。相当于以oflags标志\nO_CREAT|O_WRONLY|O_TRUNC\n来调用open。\n\n\n任何一个运行中的程序能够打开的文件数是有限制的，这个限制通常是由limits.h头文件中的常量OPEN_MAX定义的，POSIX要求它至少为16。在Linux系统中，这个限制可以在系统运行时调整。\n\n\n\n\nmy note: 在我的CentOS 7中，这个变量叫做FOPEN_MAX，其值为16。\n/usr/include/bits/stdio_lim.h:# define FOPEN_MAX 16\n\n\n\n\n访问权限的初始值\n\n\n当使用带有O_CREAT标志的open调用来创建文件时，必须使用有3个参数格式的open调用。第三个参数mode是几个标志按位或后得到的，这些标志有：\n\n\n- S_IRUSR：读权限，文件属主\n- S_IWUSR：写权限，文件属主\n- S_IXUSR：执行权限，文件属主\n- S_IRGRP：读权限，文件所属组\n- S_IWGRP：写权限，文件所属组\n- S_IXGRP：执行权限，文件所属组\n- S_IROTH：读权限，其他用户\n- S_IWOTH：写权限，其他用户\n- S_IXOTH：执行权限，其他用户\n\n\n用户掩码（由umask命令指定）会影响到被创建文件的访问权限。open调用里给出的mode值将与当时的用户掩码的反值做AND操作。\n\n\n\n\nmy note: 用户掩码中指定了不允许向某类用户提供的权限。关于umask的细节参看书本p86。\n\n\n\n\nclose系统调用\n\n\n可以使用close调用终止文件描述符与其对应文件之间的关联。文件描述符被释放并能够重新使用。close调用成功时返回0，出错时返回-1。\n\n\n#include \nunistd.h\n\n\nint close(int fd);\n\n\n\n\nioctl系统调用\n\n\nioctl提供了一个用于控制设备及其描述符行为和配置底层服务的接口。\n\n\n#include \nsys/ioctl.h\n\n\nint ioctl(int fd, int cmd, ...);\n\n\n\n\nioctl对描述符fd引用的对象执行cmd参数中给出的操作。根据特定设备所支持操作的不同，它还可能会有一个可选的第三参数。\n\n\n其他与文件管理有关的系统调用\n\n\nlseek系统调用\n\n\nlseek系统调用对文件描述符的读写指针进行设置。也就是说，可以用它来设置文件的下一个读写位置。\n\n\n#include \nsys/types.h\n\n#include \nunistd.h\n\n\noff_t lseek(int fd, off_t offset, int whence);\n\n\n\n\noffset参数用来指定位置，whence参数定义该偏移值的用法。whence可以取下列值之一：\n\n\n- SEEK_SET: offset是一个绝对位置。\n- SEEK_CUR: offset是相对于当前位置的一个相对位置。\n- SEEK_END: offset是相对于文件尾的一个相对位置。\n\n\nlseek返回从文件头到文件指针被设置处的字节偏移值，失败时返回-1。参数offset的类型off_t是一个与具体实现有关的整数类型。\n\n\nfstat, stat和lstat系统调用\n\n\nfstat系统调用返回与打开的文件描述符和相关文件的状态信息，该信息将会写到一个buf结构中，buf的地址以参数形式传递给fstat。\n\n\n#include \nsys/types.h\n\n#include \nsys/stat.h\n\n#include \nunistd.h\n\n\nint stat(const char *path, struct stat *buf);\nint fstat(int fd, struct stat *buf);\nint lstat(const char *path, struct stat *buf);\n\n\n\n\n相关函数stat和lstat返回的是通过文件名查询的状态信息。它们产生相同的结果，但当文件是一个符号链接时，lstat返回的是该符号链接本身的信息，而stat返回的是该链接指向的文件的信息。\n\n\nstat结构的成员一般会包括：\n\n\n\n\n其中st_mode标志有一些与之关联的宏，包括对访问权限、文件类型标志以及一些用于帮助测试特定类型和权限的掩码的定义。见书本p90。", 
            "title": "文件操作2"
        }, 
        {
            "location": "/ch03 文件操作_2/#_1", 
            "text": "每个运行中的程序被称为 进程 （process），它有一些与之关联的文件描述符。这是一些小值整数，你可以通过它们访问文件或设备。当一个程序开始运行时，它一般会有3个已经打开的文件描述符：  - 0：标准输入  - 1：标准输出  - 2：标准错误  你可以通过系统调用open把其他文件描述符与文件和设备相关联。   my note: 以下系统调用的函数原型用的是我使用的CentOS 7的手册页中的声明，和书中的声明略有不同。", 
            "title": "底层文件访问"
        }, 
        {
            "location": "/ch03 文件操作_2/#write", 
            "text": "系统调用write的作用是把缓冲区buf的前nbytes个字节写入与文件描述符fildes关联的文件中。它返回实际写入的字节数。如果文件描述符有错或者底层设备驱动程序对数据块长度比较敏感，该返回值可能会小于nbytes。如果这个函数返回0，就表示未写入任何数据；如果返回-1，就表示出现了错误，错误代码保存到全局变量errno里。  #include  unistd.h \n\nssize_t write(int fd, const void *buf, size_t count);  当程序退出运行时，所有已经打开的文件描述符都会自动关闭，所以你不需要明确地关闭它们。但处理被缓冲的输出时，情况就不一样了。", 
            "title": "write系统调用"
        }, 
        {
            "location": "/ch03 文件操作_2/#read", 
            "text": "系统调用read的作用是：从与文件描述符fildes相关联的文件里读入nbytes个字节的数据，并把它们放到数据区buf中。它返回实际读入的字节数，这可能会小于请求的字节数。如果read调用返回0，就表示未读入任何数据，已达到文件尾。如果返回-1，就表示出现了错误。  #include  unistd.h \n\nssize_t read(int fd, void *buf, size_t count);", 
            "title": "read系统调用"
        }, 
        {
            "location": "/ch03 文件操作_2/#open", 
            "text": "为了创建一个新的文件描述符，你需要使用系统调用open。  #include  sys/types.h \n#include  sys/stat.h \n#include  fcntl.h \n\nint open(const char *pathname, int flags);\nint open(const char *pathname, int flags, mode_t mode);\n\nint creat(const char *pathname, mode_t mode);  简单的说，open建立了一条到文件或设备的访问路径。如果调用成功，它将返回一个可以被read、write和其他系统调用使用的文件描述符。这个文件描述符是唯一的，它不会与任何其他运行中的进程共享。  oflags参数用于指定打开文件所采取的动作。它是通过命令文件访问模式与其他可选模式相结合的方式来指定的。open调用必须指定表3-1中所示的文件访问模式之一。   open调用还可以在oflags参数中包括下列可选模式的组合（用“按位或”操作）。  - O_APPEND：把写入的数据追加在文件的末尾。\n- O_TRUNC：把文件的长度设置为0，丢弃已有的内容。\n- O_CREAT：如果需要，就按照参数mode中给出的访问模式创建文件。\n- O_EXCL：与O_CREAT一起使用，确保调用者创建出文件。Open调用是一个原子操作，也就是说，它只执行一次函数调用。使用这个可选模式可以防止两个程序同时创建同一个文件。如果文件已存在，open调用将失败。  open调用失败返回-1并设置errno。新的文件描述符总是使用未用描述符的最小值。  POSIX规范还标准化了一个creat调用，它不仅会像预期那样创建文件，还会打开文件。相当于以oflags标志 O_CREAT|O_WRONLY|O_TRUNC 来调用open。  任何一个运行中的程序能够打开的文件数是有限制的，这个限制通常是由limits.h头文件中的常量OPEN_MAX定义的，POSIX要求它至少为16。在Linux系统中，这个限制可以在系统运行时调整。   my note: 在我的CentOS 7中，这个变量叫做FOPEN_MAX，其值为16。 /usr/include/bits/stdio_lim.h:# define FOPEN_MAX 16", 
            "title": "open系统调用"
        }, 
        {
            "location": "/ch03 文件操作_2/#_2", 
            "text": "当使用带有O_CREAT标志的open调用来创建文件时，必须使用有3个参数格式的open调用。第三个参数mode是几个标志按位或后得到的，这些标志有：  - S_IRUSR：读权限，文件属主\n- S_IWUSR：写权限，文件属主\n- S_IXUSR：执行权限，文件属主\n- S_IRGRP：读权限，文件所属组\n- S_IWGRP：写权限，文件所属组\n- S_IXGRP：执行权限，文件所属组\n- S_IROTH：读权限，其他用户\n- S_IWOTH：写权限，其他用户\n- S_IXOTH：执行权限，其他用户  用户掩码（由umask命令指定）会影响到被创建文件的访问权限。open调用里给出的mode值将与当时的用户掩码的反值做AND操作。   my note: 用户掩码中指定了不允许向某类用户提供的权限。关于umask的细节参看书本p86。   close系统调用  可以使用close调用终止文件描述符与其对应文件之间的关联。文件描述符被释放并能够重新使用。close调用成功时返回0，出错时返回-1。  #include  unistd.h \n\nint close(int fd);  ioctl系统调用  ioctl提供了一个用于控制设备及其描述符行为和配置底层服务的接口。  #include  sys/ioctl.h \n\nint ioctl(int fd, int cmd, ...);  ioctl对描述符fd引用的对象执行cmd参数中给出的操作。根据特定设备所支持操作的不同，它还可能会有一个可选的第三参数。", 
            "title": "访问权限的初始值"
        }, 
        {
            "location": "/ch03 文件操作_2/#_3", 
            "text": "lseek系统调用  lseek系统调用对文件描述符的读写指针进行设置。也就是说，可以用它来设置文件的下一个读写位置。  #include  sys/types.h \n#include  unistd.h \n\noff_t lseek(int fd, off_t offset, int whence);  offset参数用来指定位置，whence参数定义该偏移值的用法。whence可以取下列值之一：  - SEEK_SET: offset是一个绝对位置。\n- SEEK_CUR: offset是相对于当前位置的一个相对位置。\n- SEEK_END: offset是相对于文件尾的一个相对位置。  lseek返回从文件头到文件指针被设置处的字节偏移值，失败时返回-1。参数offset的类型off_t是一个与具体实现有关的整数类型。  fstat, stat和lstat系统调用  fstat系统调用返回与打开的文件描述符和相关文件的状态信息，该信息将会写到一个buf结构中，buf的地址以参数形式传递给fstat。  #include  sys/types.h \n#include  sys/stat.h \n#include  unistd.h \n\nint stat(const char *path, struct stat *buf);\nint fstat(int fd, struct stat *buf);\nint lstat(const char *path, struct stat *buf);  相关函数stat和lstat返回的是通过文件名查询的状态信息。它们产生相同的结果，但当文件是一个符号链接时，lstat返回的是该符号链接本身的信息，而stat返回的是该链接指向的文件的信息。  stat结构的成员一般会包括：   其中st_mode标志有一些与之关联的宏，包括对访问权限、文件类型标志以及一些用于帮助测试特定类型和权限的掩码的定义。见书本p90。", 
            "title": "其他与文件管理有关的系统调用"
        }, 
        {
            "location": "/ch08 MySQL/", 
            "text": "MySQL是一种关系型数据库管理系统（RDBMS，Relation Database Management System）。\n\n\nMySQL是开源的。\n\n\n虽然MySQL在许多场合下的使用是遵循GPL的，但是也有许多场合下必须购买它的商业许可证才能使用它。\n\n\nMySQL读如\"my sequel\"。\n\n\n安装\n\n\nCentOS 7已经安装好了MySQL，启动的命令是：\n\n\n$ systemctl start mariadb.service\n$ mysql\n\n\n\n\n其他安装方法见书本。\n\n\n安装后的配置\n\n\n安装完后，输入：\n\n\nmysql -u root mysql\n\n\n\n\n如果进入到MySQL控制台，就表示服务器正在运行。输入\\s可得到更多关于服务器的信息。输入quit或\\q退出控制台。\n\n\n使用命令\nmysql -?\n可以获得更多有关服务器的信息，此命令的输出中，有一条\nDefault options are read from the following files in the given order:\n，它告诉你在哪里可以找到配置文件，此配置文件用于配置MySQL服务器，通常是\n/etc/my.cnf\n。\n\n\n使用mysqladmin命令查看正在运行的服务器状态以及服务器的版本号：\n\n\nmysqladmin -u root version\n\n\n\n\n输出正在运行的服务器中所有的配置选项：\n\n\nmysqladmin variables -u root\n\n\n\n\n其中有几个特别有用的变量：\n\n\n- datadir，表示MySQL在哪里存储它的数据。\n\n\n- have_innodb，通常是YES，表明MySQL服务器支持InnoDB存储引擎。\n\n\n- default_storage_engine，当前MySQL服务器使用的存储引擎。\n\n\n为了把InnoDB设置成默认存储引擎，需要修改MySQL服务器配置文件，在mysqld一节中添加：\n\n\ndefault_storage_engine=InnoDB\n\n\n\n\n更多信息可访问：\nMySQL官网\n\n\n用户密码设置\n\n\nMySQL的root用户和系统的root用户毫无关系。MySQL只不过默认使用一个称为\"root\"的用户作为管理用户。\n\n\n一个最简单的设置密码的命令：\n\n\n$ mysqladmin -u root password newpassword\n\n\n\n\n或者：\n\n\n$ mysql -u root\nmysql\n SET password=PASSWORD('newpassword');\n\n\n\n\n如果想删除密码，则可以：\n\n\nmysql\n SET password=PASSWORD('');\n\n\n\n\n一条SQL命令以分号结尾，严格来说，分号不属于SQL命令的一部分，它只是用来告诉MySQL客户端程序，一条SQL语句已经准备好被执行了。\n\n\nSQL关键字不区分大小写，但使用大写可以便于阅读。\n\n\n设置了密码的用户，必须提供密码参数才能登陆MySQL客户端程序：\n\n\n$ mysql -u root -p\n\n\n\n\n检查权限表确认密码设置\n\n\nmysql\n use mysql\nmysql\n SELECT user, host, password FROM user;\n\n\n\n\nMySQL不仅能为用户保存不同的权限，也能为基于主机名的连接类保存不同的权限。\n\n\n添加用户\n\n\n以root用户身份连接到MySQL，然后使用grant命令来创建用户并赋予权限。\n\n\n例子：\n\n\n为ldw创建一个本地登录：\n\n\nmysql\n GRANT ALL ON *.* TO ldw@localhost IDENTIFIED BY '123456';\nmysql\n SELECT user, host, password FROM mysql.user;\n\n\n\n\nIDENTIFIED BY是一个用于设定初始密码的语法。\n\n\n*.*\n给予了用户非常广泛的权限。\n\n\n安装后的故障修复\n\n\n如果连接mysql失败，可使用ps命令检查服务器进程是否正在运行：\nps aux | grep mysql\n\n\n在CentOS 7上面，可以使用这个命令检查：\nsystemctl status mariadb.service\n\n\n其它的方法见书本。\n\n\nMySQL管理\n\n\n包含在MySQL发行版中的一些有用的工具程序使管理工作变得容易。\n\n\n命令\n\n\n除了mysqlshow命令外，所有的MySQL命令都接受如下3个标准参数：\n\n\n|命令选项|参数|说明|\n|-|-|\n|-u|用户名|指定一个用户名作为MySQL的用户名，默认情况下，mysql工具会尝试把当前的Linux用户名作为MySQL用户名|\n|-p|[密码]|如果给出了-p参数但是未提供密码，系统会提示输入密码。若没给-p参数，MySQL命令假设不需要密码|\n|-h|主机名|用于连接位于不同主机上的服务器。对于本地服务器，总是可以省略|\n\n\nmysql命令\n\n\n这是MySQL一个主要的且功能强大的命令行工具。\n\n\n默认使用数据库foo来启动控制台（客户端）的命令如：\n\n\n$ mysql -u ldw -p foo\n\n\n\n\n通过非交互模式运行mysql：\n\n\n$ mysql -u ldw --password=123456 foo \n sqlcmd.sql\n\n\n\n\n当mysql客户端连接到服务器后，除了标准的SQL92命令集以外，还有一些特定的命令被mysql支持。如：\n\n\n\n\n\n\n\n\n命令\n\n\n说明\n\n\n\n\n\n\n\n\n\n\nhelp\n\n\n显示命令列表\n\n\n\n\n\n\nedit\n\n\n编辑命令\n\n\n\n\n\n\nexit或quit\n\n\n退出MySQL客户端\n\n\n\n\n\n\ngo\n\n\n执行命令\n\n\n\n\n\n\nsource \nfilename\n\n\n从指定文件执行SQL\n\n\n\n\n\n\nstatus\n\n\n显示服务器状态信息\n\n\n\n\n\n\nsystem \ncommand\n\n\n执行一个系统命令\n\n\n\n\n\n\ntee \nfilename\n\n\n把所有输出的副本添加到指定文件中\n\n\n\n\n\n\nuse \ndatabase\n\n\n使用给定的数据库\n\n\n\n\n\n\n\n\nMySQL最常使用的术语是database，它是一个基本独立的表格集。可以为每个数据库指定不同的用户，只要拥有适当的权限，就可以通过use命令在不同的数据库之间进行切换。\n\n\n特定数据库mysql是由MySQL安装自动创建的，它用于保存如用户和权限这样的数据。\n\n\nmysqladmin\n\n\n快速进行MySQL数据库管理的主要工具。除了常见参数，还支持如下命令：\n\n\n\n\n\n\n\n\n命令\n\n\n说明\n\n\n\n\n\n\n\n\n\n\ncreate \ndatabase_name\n\n\n创建一个新数据库\n\n\n\n\n\n\ndrop \ndatabase_name\n\n\n删除一个数据库\n\n\n\n\n\n\npassword \nnew_password\n\n\n修改密码\n\n\n\n\n\n\nping\n\n\n检查服务器是否正在运行\n\n\n\n\n\n\nreload\n\n\n重载控制权限的grant表\n\n\n\n\n\n\nstatus\n\n\n提供服务器的状态\n\n\n\n\n\n\nshutdown\n\n\n停止服务器\n\n\n\n\n\n\nvariables\n\n\n显示控制MySQL操作的变量及其当前值\n\n\n\n\n\n\nversion\n\n\n提供服务器的版本号以及它持续运行的时间\n\n\n\n\n\n\n\n\n如果不带参数调用mysqladmin命令，就可以从命令提示符下看到完整的选项列表。\n\n\nmysqldump\n\n\nmysqldump命令允许以SQL命令集的形式将部分或整个数据库导出到一个单独的文件中，该文件能被重新导入MySQL或其他的SQL RDBMS。\n\n\n以下参数扩展了这个工具的功能：\n\n\n\n\n\n\n\n\n命令\n\n\n说明\n\n\n\n\n\n\n\n\n\n\n-add-drop-table\n\n\n添加SQL命令到输出文件，以在创建表的命令之前丢弃（删除）任何表\n\n\n\n\n\n\n-e\n\n\n使用扩展的insert语法\n\n\n\n\n\n\n-t\n\n\n只转储表中的数据，而不是用来创建表的信息\n\n\n\n\n\n\n-d\n\n\n只转储表结构，而不是实际数据\n\n\n\n\n\n\n\n\n默认情况下，mysqldump将数据发送到标准输出，可以把它重定向到文件。\n\n\nmysqldump命令对于迁移数据或快速备份非常有用。\n\n\n一个转储数据库的例子：\n\n\n$ mysqldump -u ldw -p123456 \n foo_bak.dump\n\n\n\n\nmysqlimport\n\n\nmysqlimport命令用于批量将数据导入到一个表中。\n\n\nmysqlshow\n\n\n这个小工具能够让你快速了解MySQL安装及其组成数据库的信息。\n\n\n- 不提供参数，列出所有可用的数据库。\n\n\n- 以一个数据库为参数，列出该数据库中的表。\n\n\n- 以数据库和表名为参数，列出表的列。\n\n\n- 以数据库、表和列为参数，列出指定列的详细信息。\n\n\n创建用户并赋予权限\n\n\nMySQL管理员最常见的工作就是维护用户信息——在MySQL中添加和删除用户并管理他们的权限。\n\n\n通过在MySQL控制台中使用grant和revoke命令来管理用户权限。\n\n\ngrant命令\n\n\nMySQL的grant命令几乎完全遵循SQL92的语法。其常规格式是：\n\n\ngrant \nprivilege\n on \nobject\n to \nuser\n [identified by user-password] [with grant option];\n\n\n\n\n可以授予的特权值见书本。\n\n\n授予特权的对象被标识为：database_name.table_name\n\n\n在Linux传统中，*代表通配符，因此*.*代表每个数据库中的每个对象，foo.*代表数据库foo中的每个表。\n\n\n如果指定的用户已经存在，他的特权会被编辑以反映所做的修改。如果用户不存在，他就会以指定的特权被创建。\n\n\n在SQL语法中，特殊字符%代表通配符，它与shell环境中的*号的作用完全一致。任何时候使用%通配符都必须把它放到引号中，以与其他文本分开。\n\n\n创建一个可以从任何主机进行连接的用户：\n\n\nmysql\n GRANT ALL ON foo.* TO ldw@'%' IDENTIFIED BY '123456';\n\n\n\n\nrevoke命令\n\n\n管理员可以剥夺用户的权限。通过revoke命令：\n\n\nrevoke \na_privilege\n on \nan_object\n from \na_user\n\n\n\n\n\n如：\n\n\nmysql\n REVOKE INSERT ON foo.* FROM rick@'%';\n\n\n\n\nrevoke命令不能删除用户，如果要完全删除一个用户，不要只是修改他们的权限，而应用revoke来删除他们的权限。然后，切换到mysql数据库，通过从user表中删除相应的行来完全删除一个用户：\n\n\nmysql\n use mysql\nmysql\n DELETE FROM USER WHERE user = \nldw\n;\nmysql\n FLUSH PRIVILEGES;\n\n\n\n\nFLUSH PRIVILEGES告诉服务器，需要重载权限表。\n\n\n密码\n\n\n如果想为尚未拥有密码的用户指定密码，或者希望改变自己或别人的密码，你就需要以root用户身份连接到MySQL服务器，然后直接更新用户信息。例如：\n\n\nmysql\n use mysql\nmysql\n UPDATE user SET password = password('bar') WHERE user = 'ldw';\nmysql\n FLUSH PRIVILEGES;\n\n\n\n\n创建数据库\n\n\n创建一个数据库的命令可以是：\n\n\nmysql\n CREATE DATABASE test;\n\n\n\n\n数据类型\n\n\nMySQL的数据类型非常标准，书本里只做了简要的浏览，MySQL网站上的MySQL手册对此进行了更为详细的讨论。\n\n\n见书本。\n\n\n创建表\n\n\n一个数据库表非常像电子表格，除了每行都必须包含相同数目和类型的列，而且每行必须以某种方式不同于表中的其他行。\n\n\n创建数据库对象的完整SQL语法被称为DDL（data definition language, 数据库定义语言）。\n\n\n见书本。\n\n\n图形化工具\n\n\n我使用工作上用的navicat, 其它工具见书本。\n\n\n使用C语言访问MySQL数据库\n\n\n可以使用许多不同的编程语言来访问MySQL，比如C, C++, PHP, Python。在此讨论C语言的接口。\n\n\n连接例程\n\n\n见connect1.c。\n\n\n用C语言连接MySQL数据库包含两个步骤：\n\n\n- 初始化一个连接句柄结构；\n\n\n- 实际进行连接。\n\n\n使用mysql_init来初始化连接句柄：\n\n\n#include \nmysql.h\n\nMYSQL *mysql_init(MYSQL *);\n\n\n\n\n如果传递给NULL给此接口，它会返回一个指向新分配的连接句柄结构的指针。如果传递一个已有结构，它将被重新初始化。出错时返回NULL。\n\n\n使用mysql_real_connect来向一个连接提供参数：\n\n\nMYSQL *mysql_real_connect(MYSQL *connection,\n    const char *server_host,\n    const char *sql_user_name,\n    const char *sql_password,\n    const char *db_name,\n    usigned int port_number,\n    const char *unix_sock_name,\n    unsigned int flags);\n\n\n\n\nconnection必须指向已经被mysql_init初始化过的结构。server_host是主机名（可以是IP地址，或者localhost）。sql_user_name和sql_password和字面含义一样。\n\n\nport_number和unix_socket_name默认为0和NULL，表示采用MySQL的默认设置。\n\n\nflag参数默认填0即可，对于介绍性的章节来说，没什么用。\n\n\n使用完连接之后，通常在程序退出时，调用mysql_close关闭连接：\n\n\nvoid mysql_close(MYSQL *connection);\n\n\n\n\n如果connection是由mysql_init建立的，MYSQL结构会被释放，指针将会失效并无法再次使用。\n\n\nmysql_options仅能在mysql_init和mysql_real_connect之间调用，可以设置一些选项。见书本。\n\n\n错误处理\n\n\n见connect2.c。\n\n\nMySQL使用一系列由连接句柄结构报告的返回码。两个必备的例程是：\n\n\nunsigned int mysql_errno(MYSQL *connection);\nchar *mysql_error(MYSQL *connection);\n\n\n\n\nmysql_errno获得错误码，如果未设定错误，它将返回0。因为每次调用库都会更新错误码，所以只能得到最后一个执行命令的错误码，但上面两个例程是例外，它们不会导致错误码更新。\n\n\nmysql_error获得文本错误信息，这些信息被写入一些内部静态内存空间中，如果想保存错误文本，需要把它复制到别的地方。\n\n\n执行SQL语句\n\n\n见insert1.c。\n\n\n执行SQL语句的主要API函数为：\n\n\nint mysql_query(MYSQL *connection, const char *query);\n\n\n\n\nquery是字符串形式的有效SQL语句（没有结束的分号）。如果成功，返回0。对于包含二进制数据的查询，可以使用mysql_real_query。\n\n\n用于检测受影响的行数的函数：\n\n\nmy_ulonglong mysql_affected_rows(MYSQL *connection);\n\n\n\n\n返回一个my_ulonglong类型是出于移植性的考虑，可以把它转换成无符号长整型。函数返回受之前的UPDATE, INSERT, DELETE查询影响的行数。\n\n\n通常返回值0表示没有行受到影响，正数则是实际的结果，一般表示受语句影响的行数。如果是DELETE删除整个表的数据，由程序返回的结果是0。\n\n\n发现插入的内容\n\n\n见insert2.c。\n\n\n如果一个列的类型是AUTO_INCREMENT，那么它会由MySQL自动分配ID。如何知道刚刚插入的记录的这个ID呢？\n\n\nMySQL提供了LAST_INSERT_ID()函数，无论何时MySQL向AUTO_INCREMENT列中插入数据，MySQL都会基于每个用户对最后分配的值进行跟踪。用户可以这样发现该值：\n\n\nmysql\n SELECT LAST_INSERT_ID();\n\n\n\n\n返回的数字在本次会话中是唯一的。\n\n\n返回数据的语句\n\n\n见select*.c。\n\n\n数据是使用SELECT语句提取的。\n\n\n在C应用程序中提取数据一般需要下面4个步骤：\n\n\n- 执行查询；\n\n\n- 提取数据；\n\n\n- 处理数据；\n\n\n- 必要的清理工作。\n\n\n使用完mysql_qurey发送SQL语句后，使用mysql_store_result或mysql_use_result来提取数据。接着使用一系列mysql_fetch_row调用来处理数据。最后使用mysql_free_result释放查询占用的内存资源。\n\n\n一次提取所有数据的函数\n\n\n可以使用mysql_store_result在一次调用中从SELECT中提取所有数据：\n\n\nMYSQL_RES *mysql_store_result(MYSQL *connection);\n\n\n\n\n需要在成功调用mysql_query之后使用此函数。这个函数将立刻保存在客户端中返回的所有数据。它返回一个指向结果集结构的指针，如果失败则返回NULL。\n\n\nmysql_num_rows返回记录的数据，如果没有返回行，这个值将是0。\n\n\nmy_ulonglong mysql_num_rows(MYSQL_RES *result);\n\n\n\n\n接下来，可以使用mysql_fetch_row来处理结果集，也可以使用mysql_data_seek, mysql_row_seek, mysql_row_tell在数据集中来回移动。\n\n\nmysql_fetch_row: 这个函数从结果集中提取一行数据，并把它放到一个行结构中。当数据用完或发生错误时返回NULL。\n\n\nMYSQL_ROW mysql_fetch_row(MYSQL_RES *result);\n\n\n\n\n在完成了对结果集的操作后，必须总是调用mysql_free_result函数来让MySQL库清理它分配的对象：\n\n\nvoid mysql_free_result(MYSQL_RES *result);\n\n\n\n\n一次提取一行数据\n\n\n依靠mysql_use_result可以逐行提取数据：\n\n\nMYSQL_RES *mysql_use_result(MYSQL *connection);\n\n\n\n\nmysql_use_result在遇到错误时返回NULL。如果成功，返回指向结果集对象的指针。但是，它未将提取的数据放到它初始化的结果集中。\n\n\n在之后使用mysql_fetch_row返回行结果必须通过网络。\n\n\n处理返回的数据\n\n\nMySQL返回两种类型的数据：\n\n\n- 列数据，即从表中提取的信息\n\n\n- 元数据（matadata），如列名和类型\n\n\nmysql_field_count函数返回结果集中的字段（列）数目：\n\n\nunsigned int mysql_field_count(MYSQL *connection);\n\n\n\n\n使用mysql_fetch_field函数可以将元数据和数据提取到一个新的结构中：\n\n\nMYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result);\n\n\n\n\n此函数需要重复调用，直到返回表示数据结束的NULL值为止。MYSQL_FIELD包含了关于列的信息。见书本。\n\n\n更多的函数\n\n\n见书本。", 
            "title": "ch08 MySQL"
        }, 
        {
            "location": "/ch08 MySQL/#_1", 
            "text": "CentOS 7已经安装好了MySQL，启动的命令是：  $ systemctl start mariadb.service\n$ mysql  其他安装方法见书本。", 
            "title": "安装"
        }, 
        {
            "location": "/ch08 MySQL/#_2", 
            "text": "安装完后，输入：  mysql -u root mysql  如果进入到MySQL控制台，就表示服务器正在运行。输入\\s可得到更多关于服务器的信息。输入quit或\\q退出控制台。  使用命令 mysql -? 可以获得更多有关服务器的信息，此命令的输出中，有一条 Default options are read from the following files in the given order: ，它告诉你在哪里可以找到配置文件，此配置文件用于配置MySQL服务器，通常是 /etc/my.cnf 。  使用mysqladmin命令查看正在运行的服务器状态以及服务器的版本号：  mysqladmin -u root version  输出正在运行的服务器中所有的配置选项：  mysqladmin variables -u root  其中有几个特别有用的变量：  - datadir，表示MySQL在哪里存储它的数据。  - have_innodb，通常是YES，表明MySQL服务器支持InnoDB存储引擎。  - default_storage_engine，当前MySQL服务器使用的存储引擎。  为了把InnoDB设置成默认存储引擎，需要修改MySQL服务器配置文件，在mysqld一节中添加：  default_storage_engine=InnoDB  更多信息可访问： MySQL官网  用户密码设置  MySQL的root用户和系统的root用户毫无关系。MySQL只不过默认使用一个称为\"root\"的用户作为管理用户。  一个最简单的设置密码的命令：  $ mysqladmin -u root password newpassword  或者：  $ mysql -u root\nmysql  SET password=PASSWORD('newpassword');  如果想删除密码，则可以：  mysql  SET password=PASSWORD('');  一条SQL命令以分号结尾，严格来说，分号不属于SQL命令的一部分，它只是用来告诉MySQL客户端程序，一条SQL语句已经准备好被执行了。  SQL关键字不区分大小写，但使用大写可以便于阅读。  设置了密码的用户，必须提供密码参数才能登陆MySQL客户端程序：  $ mysql -u root -p  检查权限表确认密码设置  mysql  use mysql\nmysql  SELECT user, host, password FROM user;  MySQL不仅能为用户保存不同的权限，也能为基于主机名的连接类保存不同的权限。  添加用户  以root用户身份连接到MySQL，然后使用grant命令来创建用户并赋予权限。  例子：  为ldw创建一个本地登录：  mysql  GRANT ALL ON *.* TO ldw@localhost IDENTIFIED BY '123456';\nmysql  SELECT user, host, password FROM mysql.user;  IDENTIFIED BY是一个用于设定初始密码的语法。  *.* 给予了用户非常广泛的权限。", 
            "title": "安装后的配置"
        }, 
        {
            "location": "/ch08 MySQL/#_3", 
            "text": "如果连接mysql失败，可使用ps命令检查服务器进程是否正在运行： ps aux | grep mysql  在CentOS 7上面，可以使用这个命令检查： systemctl status mariadb.service  其它的方法见书本。", 
            "title": "安装后的故障修复"
        }, 
        {
            "location": "/ch08 MySQL/#mysql", 
            "text": "包含在MySQL发行版中的一些有用的工具程序使管理工作变得容易。", 
            "title": "MySQL管理"
        }, 
        {
            "location": "/ch08 MySQL/#_4", 
            "text": "除了mysqlshow命令外，所有的MySQL命令都接受如下3个标准参数：  |命令选项|参数|说明|\n|-|-|\n|-u|用户名|指定一个用户名作为MySQL的用户名，默认情况下，mysql工具会尝试把当前的Linux用户名作为MySQL用户名|\n|-p|[密码]|如果给出了-p参数但是未提供密码，系统会提示输入密码。若没给-p参数，MySQL命令假设不需要密码|\n|-h|主机名|用于连接位于不同主机上的服务器。对于本地服务器，总是可以省略|  mysql命令  这是MySQL一个主要的且功能强大的命令行工具。  默认使用数据库foo来启动控制台（客户端）的命令如：  $ mysql -u ldw -p foo  通过非交互模式运行mysql：  $ mysql -u ldw --password=123456 foo   sqlcmd.sql  当mysql客户端连接到服务器后，除了标准的SQL92命令集以外，还有一些特定的命令被mysql支持。如：     命令  说明      help  显示命令列表    edit  编辑命令    exit或quit  退出MySQL客户端    go  执行命令    source  filename  从指定文件执行SQL    status  显示服务器状态信息    system  command  执行一个系统命令    tee  filename  把所有输出的副本添加到指定文件中    use  database  使用给定的数据库     MySQL最常使用的术语是database，它是一个基本独立的表格集。可以为每个数据库指定不同的用户，只要拥有适当的权限，就可以通过use命令在不同的数据库之间进行切换。  特定数据库mysql是由MySQL安装自动创建的，它用于保存如用户和权限这样的数据。  mysqladmin  快速进行MySQL数据库管理的主要工具。除了常见参数，还支持如下命令：     命令  说明      create  database_name  创建一个新数据库    drop  database_name  删除一个数据库    password  new_password  修改密码    ping  检查服务器是否正在运行    reload  重载控制权限的grant表    status  提供服务器的状态    shutdown  停止服务器    variables  显示控制MySQL操作的变量及其当前值    version  提供服务器的版本号以及它持续运行的时间     如果不带参数调用mysqladmin命令，就可以从命令提示符下看到完整的选项列表。  mysqldump  mysqldump命令允许以SQL命令集的形式将部分或整个数据库导出到一个单独的文件中，该文件能被重新导入MySQL或其他的SQL RDBMS。  以下参数扩展了这个工具的功能：     命令  说明      -add-drop-table  添加SQL命令到输出文件，以在创建表的命令之前丢弃（删除）任何表    -e  使用扩展的insert语法    -t  只转储表中的数据，而不是用来创建表的信息    -d  只转储表结构，而不是实际数据     默认情况下，mysqldump将数据发送到标准输出，可以把它重定向到文件。  mysqldump命令对于迁移数据或快速备份非常有用。  一个转储数据库的例子：  $ mysqldump -u ldw -p123456   foo_bak.dump  mysqlimport  mysqlimport命令用于批量将数据导入到一个表中。  mysqlshow  这个小工具能够让你快速了解MySQL安装及其组成数据库的信息。  - 不提供参数，列出所有可用的数据库。  - 以一个数据库为参数，列出该数据库中的表。  - 以数据库和表名为参数，列出表的列。  - 以数据库、表和列为参数，列出指定列的详细信息。", 
            "title": "命令"
        }, 
        {
            "location": "/ch08 MySQL/#_5", 
            "text": "MySQL管理员最常见的工作就是维护用户信息——在MySQL中添加和删除用户并管理他们的权限。  通过在MySQL控制台中使用grant和revoke命令来管理用户权限。  grant命令  MySQL的grant命令几乎完全遵循SQL92的语法。其常规格式是：  grant  privilege  on  object  to  user  [identified by user-password] [with grant option];  可以授予的特权值见书本。  授予特权的对象被标识为：database_name.table_name  在Linux传统中，*代表通配符，因此*.*代表每个数据库中的每个对象，foo.*代表数据库foo中的每个表。  如果指定的用户已经存在，他的特权会被编辑以反映所做的修改。如果用户不存在，他就会以指定的特权被创建。  在SQL语法中，特殊字符%代表通配符，它与shell环境中的*号的作用完全一致。任何时候使用%通配符都必须把它放到引号中，以与其他文本分开。  创建一个可以从任何主机进行连接的用户：  mysql  GRANT ALL ON foo.* TO ldw@'%' IDENTIFIED BY '123456';  revoke命令  管理员可以剥夺用户的权限。通过revoke命令：  revoke  a_privilege  on  an_object  from  a_user   如：  mysql  REVOKE INSERT ON foo.* FROM rick@'%';  revoke命令不能删除用户，如果要完全删除一个用户，不要只是修改他们的权限，而应用revoke来删除他们的权限。然后，切换到mysql数据库，通过从user表中删除相应的行来完全删除一个用户：  mysql  use mysql\nmysql  DELETE FROM USER WHERE user =  ldw ;\nmysql  FLUSH PRIVILEGES;  FLUSH PRIVILEGES告诉服务器，需要重载权限表。", 
            "title": "创建用户并赋予权限"
        }, 
        {
            "location": "/ch08 MySQL/#_6", 
            "text": "如果想为尚未拥有密码的用户指定密码，或者希望改变自己或别人的密码，你就需要以root用户身份连接到MySQL服务器，然后直接更新用户信息。例如：  mysql  use mysql\nmysql  UPDATE user SET password = password('bar') WHERE user = 'ldw';\nmysql  FLUSH PRIVILEGES;", 
            "title": "密码"
        }, 
        {
            "location": "/ch08 MySQL/#_7", 
            "text": "创建一个数据库的命令可以是：  mysql  CREATE DATABASE test;", 
            "title": "创建数据库"
        }, 
        {
            "location": "/ch08 MySQL/#_8", 
            "text": "MySQL的数据类型非常标准，书本里只做了简要的浏览，MySQL网站上的MySQL手册对此进行了更为详细的讨论。  见书本。", 
            "title": "数据类型"
        }, 
        {
            "location": "/ch08 MySQL/#_9", 
            "text": "一个数据库表非常像电子表格，除了每行都必须包含相同数目和类型的列，而且每行必须以某种方式不同于表中的其他行。  创建数据库对象的完整SQL语法被称为DDL（data definition language, 数据库定义语言）。  见书本。", 
            "title": "创建表"
        }, 
        {
            "location": "/ch08 MySQL/#_10", 
            "text": "我使用工作上用的navicat, 其它工具见书本。", 
            "title": "图形化工具"
        }, 
        {
            "location": "/ch08 MySQL/#cmysql", 
            "text": "可以使用许多不同的编程语言来访问MySQL，比如C, C++, PHP, Python。在此讨论C语言的接口。", 
            "title": "使用C语言访问MySQL数据库"
        }, 
        {
            "location": "/ch08 MySQL/#_11", 
            "text": "见connect1.c。  用C语言连接MySQL数据库包含两个步骤：  - 初始化一个连接句柄结构；  - 实际进行连接。  使用mysql_init来初始化连接句柄：  #include  mysql.h \nMYSQL *mysql_init(MYSQL *);  如果传递给NULL给此接口，它会返回一个指向新分配的连接句柄结构的指针。如果传递一个已有结构，它将被重新初始化。出错时返回NULL。  使用mysql_real_connect来向一个连接提供参数：  MYSQL *mysql_real_connect(MYSQL *connection,\n    const char *server_host,\n    const char *sql_user_name,\n    const char *sql_password,\n    const char *db_name,\n    usigned int port_number,\n    const char *unix_sock_name,\n    unsigned int flags);  connection必须指向已经被mysql_init初始化过的结构。server_host是主机名（可以是IP地址，或者localhost）。sql_user_name和sql_password和字面含义一样。  port_number和unix_socket_name默认为0和NULL，表示采用MySQL的默认设置。  flag参数默认填0即可，对于介绍性的章节来说，没什么用。  使用完连接之后，通常在程序退出时，调用mysql_close关闭连接：  void mysql_close(MYSQL *connection);  如果connection是由mysql_init建立的，MYSQL结构会被释放，指针将会失效并无法再次使用。  mysql_options仅能在mysql_init和mysql_real_connect之间调用，可以设置一些选项。见书本。", 
            "title": "连接例程"
        }, 
        {
            "location": "/ch08 MySQL/#_12", 
            "text": "见connect2.c。  MySQL使用一系列由连接句柄结构报告的返回码。两个必备的例程是：  unsigned int mysql_errno(MYSQL *connection);\nchar *mysql_error(MYSQL *connection);  mysql_errno获得错误码，如果未设定错误，它将返回0。因为每次调用库都会更新错误码，所以只能得到最后一个执行命令的错误码，但上面两个例程是例外，它们不会导致错误码更新。  mysql_error获得文本错误信息，这些信息被写入一些内部静态内存空间中，如果想保存错误文本，需要把它复制到别的地方。", 
            "title": "错误处理"
        }, 
        {
            "location": "/ch08 MySQL/#sql", 
            "text": "见insert1.c。  执行SQL语句的主要API函数为：  int mysql_query(MYSQL *connection, const char *query);  query是字符串形式的有效SQL语句（没有结束的分号）。如果成功，返回0。对于包含二进制数据的查询，可以使用mysql_real_query。  用于检测受影响的行数的函数：  my_ulonglong mysql_affected_rows(MYSQL *connection);  返回一个my_ulonglong类型是出于移植性的考虑，可以把它转换成无符号长整型。函数返回受之前的UPDATE, INSERT, DELETE查询影响的行数。  通常返回值0表示没有行受到影响，正数则是实际的结果，一般表示受语句影响的行数。如果是DELETE删除整个表的数据，由程序返回的结果是0。  发现插入的内容  见insert2.c。  如果一个列的类型是AUTO_INCREMENT，那么它会由MySQL自动分配ID。如何知道刚刚插入的记录的这个ID呢？  MySQL提供了LAST_INSERT_ID()函数，无论何时MySQL向AUTO_INCREMENT列中插入数据，MySQL都会基于每个用户对最后分配的值进行跟踪。用户可以这样发现该值：  mysql  SELECT LAST_INSERT_ID();  返回的数字在本次会话中是唯一的。  返回数据的语句  见select*.c。  数据是使用SELECT语句提取的。  在C应用程序中提取数据一般需要下面4个步骤：  - 执行查询；  - 提取数据；  - 处理数据；  - 必要的清理工作。  使用完mysql_qurey发送SQL语句后，使用mysql_store_result或mysql_use_result来提取数据。接着使用一系列mysql_fetch_row调用来处理数据。最后使用mysql_free_result释放查询占用的内存资源。  一次提取所有数据的函数  可以使用mysql_store_result在一次调用中从SELECT中提取所有数据：  MYSQL_RES *mysql_store_result(MYSQL *connection);  需要在成功调用mysql_query之后使用此函数。这个函数将立刻保存在客户端中返回的所有数据。它返回一个指向结果集结构的指针，如果失败则返回NULL。  mysql_num_rows返回记录的数据，如果没有返回行，这个值将是0。  my_ulonglong mysql_num_rows(MYSQL_RES *result);  接下来，可以使用mysql_fetch_row来处理结果集，也可以使用mysql_data_seek, mysql_row_seek, mysql_row_tell在数据集中来回移动。  mysql_fetch_row: 这个函数从结果集中提取一行数据，并把它放到一个行结构中。当数据用完或发生错误时返回NULL。  MYSQL_ROW mysql_fetch_row(MYSQL_RES *result);  在完成了对结果集的操作后，必须总是调用mysql_free_result函数来让MySQL库清理它分配的对象：  void mysql_free_result(MYSQL_RES *result);  一次提取一行数据  依靠mysql_use_result可以逐行提取数据：  MYSQL_RES *mysql_use_result(MYSQL *connection);  mysql_use_result在遇到错误时返回NULL。如果成功，返回指向结果集对象的指针。但是，它未将提取的数据放到它初始化的结果集中。  在之后使用mysql_fetch_row返回行结果必须通过网络。  处理返回的数据  MySQL返回两种类型的数据：  - 列数据，即从表中提取的信息  - 元数据（matadata），如列名和类型  mysql_field_count函数返回结果集中的字段（列）数目：  unsigned int mysql_field_count(MYSQL *connection);  使用mysql_fetch_field函数可以将元数据和数据提取到一个新的结构中：  MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result);  此函数需要重复调用，直到返回表示数据结束的NULL值为止。MYSQL_FIELD包含了关于列的信息。见书本。", 
            "title": "执行SQL语句"
        }, 
        {
            "location": "/ch08 MySQL/#_13", 
            "text": "见书本。", 
            "title": "更多的函数"
        }, 
        {
            "location": "/ch15 套接字_1/", 
            "text": "套接字接口（socket interface）\n是一种通信工具。一台机器上的进程可以使用套接字和另外一台机器上的进程通信，这样就可以支持分布在网络中的客户/服务器系统。同一台机器上的进程之间也可以使用套接字进行通信。\n\n\n什么是套接字\n\n\n套接字是一种通信机制，它明确地将客户和服务器区分开来。套接字机制可以实现多个客户端连接到一个服务器。\n\n\n套接字连接\n\n\n首先，服务器应用程序用系统调用socket来创建一个套接字，它是类似文件描述符的资源，不能与其他进程共享。\n\n\n接下来，服务器进程会给套接字起个名字。本地套接字的名字是Linux文件系统中的文件名，一般放在/tmp或/usr/tmp目录中。对于网络套接字，它的名字是与网络有关的标识符（比如端口号）。这个标识符允许Linux将进入的针对特定端口号的连接转到正确的服务器进程。\n\n\n我们用系统调用bind来给套接字命名。然后服务器进程就开始等待客户端连接到这个命名套接字。\n\n\n系统调用listen的作用是，创建一个队列并将其用于存放来自客户的进入连接。服务器通过系统调用accept来接受客户的连接。\n\n\n服务器调用accept时，它会创建一个新套接字，这个新套接字只用于与这个特定的客户进行通信。而命名套接字则被保留下来继续处理来自其他客户的连接。\n\n\n基于套接字系统的客户端首先调用socket创建一个未命名套接字，然后将服务器的命名套接字作为一个地址，调用connect与服务器建立连接。\n\n\n一旦连接建立，我们就可以开始双向的数据通信。\n\n\n一个简单的案例见：client1.c, server1.c\n\n\n套接字属性\n\n\n套接字的特性由3个属性确定：域（domain）、类型（type）和协议（protocol）。套接字还用地址作为它的名字。\n\n\n套接字的域\n\n\n域指定套接字通信中使用的网络介质。最常见的套接字域是AF_INET（adress format internet），它指的是Internet网络，并使用IP地址来指定网络中的计算机。\n\n\n所有的IP地址都用4个数字来表示，每个数字都小于256，即所谓的点分四元组表示法（dotted quad）。\n\n\n当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址。客户可以通过IP端口来指定一台联网机器上的某个特定服务。端口通过分配一个唯一的16位整数来标识。套接字必须在开始通信之前绑定一个端口。\n\n\n书中第一个例子的域是UNIX文件系统域AF_UNIX，它的地址就是文件名。还有一些其他的域，但不在讨论范围。\n\n\n\n\n套接字类型\n\n\n因特网协议提供了了两种通信机制：流（stream）和数据报（datagram）。\n\n\n流套接字\n\n\n流套接字提供的是一个有序、可靠、双向字节流的连接。\n\n\n流套接字由类型SOCK_STREAM指定，它们是在AF_INET域中通过TCP/IP连接实现的。\n\n\n数据报套接字\n\n\n由类型SOCK_DGRAM指定，它不建立和维持一个连接。它对可以发送的数据报的长度有限制。数据报作为一个单独的网络消息被传输，它可能会丢失、复制或乱序到达。\n\n\n数据报套接字是在AF_INET域中通过UDP/IP连接实现的，它提供的是一种无序的不可靠服务。相对来说它们开销比较小，速度也很快。\n\n\n\n\n套接字协议\n\n\nUNIX网络套接字和文件系统套接字不需要选择一个特定的协议，只需要使用其默认值即可。\n\n\n创建套接字\n\n\nsocket系统调用创建一个套接字并返回一个描述符，该描述符可以用来访问该套接字。\n\n\n#include \nsys/types.h\n\n#include \nsys/socket.h\n\n\nint socket(int domain, int type, int protocol);\n\n\n\n\n创建的套接字是一条通信线路的一个端点。domain参数最常用的取值是AF_UNIX和AF_INET。type的取值可以是SOCK_STREAM和SOCK_DGRAM。protocol通常不需要选择，本章节中都是用0，表示使用默认协议。\n\n\n套接字地址\n\n\n每个套接字域都有自己的地址格式。对于AF_UNIX域套接字来说，它的地址由结构sockaddr_un来描述：\n\n\n#include \nsys/un.h\n\n\nstruct sockaddr_un {\n    sa_family_t    sun_family;    /* AF_UNIX */\n    char           sun_path[];    /* pathname */\n};\n\n\n\n\n对套接字进行处理的系统调用可能需要接受不同类型的地址，每种地址格式都使用一种类似的结构来描述，它们都以一个指定地址类型（套接字域）的成员开始。\n\n\n在AF_INET域中，套接字地址由结构sockaddr_in来指定：\n\n\n#include \nnetinet/in.h\n\n\nstruct sockaddr_in {\n    short int          sin_family;    /* AF_INET */\n    unsigned short int sin_port;      /* Port number */\n    struct in_addr     sin_addr;      /* Internet address */\n};\n\n\n\n\n结构in_addr是IP地址：\n\n\nstruct in_addr {\n    unsigned long int s_addr;\n};\n\n\n\n\nIP地址中的4个字节组成一个32位的值。一个AF_INET套接字由它的域、IP地址和端口号完全确定。\n\n\n命名套接字\n\n\n想要套接字被使用，服务器程序就必须给该套接字命名。这样，AF_UNIX套接字就会关联到一个文件系统的路径名。AF_INET套接字就会关联到一个IP端口号。\n\n\n#include \nsys/socket.h\n\n\nint bind(int socket, const struct sockaddr *address, size_t address_len);\n\n\n\n\nbind系统调用把参数address中的地址分配给与socket描述符关联的未命名套接字。地址结构的长度由参数address_len传递。\n\n\nbind函数调用成功返回0，失败返回-1并设置errno。可取值见书本。\n\n\n创建套接字队列\n\n\n为了能够在套接字上接受进入的连接，服务器程序必须创建一个队列来保存未处理的请求。\n\n\n#include \nsys/socket.h\n\n\nint listen(int socket, int backlog);\n\n\n\n\nlisten函数将队列长度设置为backlog参数的值，等待处理的进入连接的个数最多不能超过这个数字。再往后的连接将被拒绝，导致客户的连接请求失败。backog参数常用的值是5。\n\n\nlisten函数成功返回0，失败返回-1并设置errno。见书本。\n\n\n接受连接\n\n\n通过accept系统调用来等待客户建立对该套接字的连接。\n\n\n#include \nsys/socket.h\n\n\nint accept(int socket, struct sockaddr *address, size_t *address_len);\n\n\n\n\naccept系统调用只有当客户程序试图连接到由socket参数指定的套接字上时才会返回。这里的客户指的是在套接字队列中排在第一个的未处理的连接。accept函数将创建一个新套接字来与该客户进行通信，并且返回新套接字的描述符。\n\n\n连接客户的地址将被放入address参数指向的sockaddr结构中，如果不关心这个地址，可以设置为空指针。\n\n\n参数address_len指定客户结构的长度，如果客户地址的长度超过这个值，它将被截断。这个调用返回时，address_len将被设置为连接客户地址结构的实际长度。\n\n\n如果套接字队列中没有未处理的连接，accept将阻塞直到有客户建立连接为止。可以通过对套接字描述符设置O_NONBLOCK标志来改变这一行为：\n\n\nint flags = fcntl(sock, F_GETFL, 0);\nfcntl(socket, F_SETFL, O_NONBLOCK|flags);\n\n\n\n\n如果发生错误，accept函数将返回-1。\n\n\n请求连接\n\n\n客户程序通过在一个未命名套接字和服务器监听套接字之间建立连接的方法来连接到服务器。\n\n\n#include \nsys/socket.h\n\n\nint connect(int socket, const struct sockaddr *address, size_t address_len);\n\n\n\n\n参数socket是通过socket调用获得的一个有效的描述符，其指定的套接字将连接到参数address指定的服务器套接字，address指向的结构的长度由参数address_len指定。\n\n\n成功时，connect调用返回0，失败时返回-1，并设置errno。见书本。\n\n\n如果连接不能立刻建立，connect调用将阻塞一段不确定的超时时间，一旦超时时间到达，连接将被放弃，connect调用失败。\n\n\nconnect调用的阻塞特性可以通过设置该文件描述符的O_NONBLOCK标志来改变，此时如果连接不能立刻建立，connect将失败并把errno设置为EINPROGRESS，而连接将以异步方式继续进行。可以用select调用来检查套接字是否已处于写就绪状态。\n\n\n关闭套接字\n\n\n你可以通过调用close函数来终止服务器和客户上的套接字连接。\n\n\n对于服务器来说，应该在read调用返回0时关闭套接字，但如果套接字是一个面向连接类型的，并设置了SOCK_LINGER选项，close调用会在该套接字还有未传输数据时阻塞。\n\n\n套接字通讯\n\n\n我们不能使用小于1024的端口号，因为它们是为系统使用保留的。其它的端口号信息通常列在系统文件\n/etc/services\n中。编写基于套接字的应用程序时，请注意总要选择没有列在该配置文件中的端口号。\n\n\n我们将在局域网中运行客户和服务器。UNIX计算机通常会配置一个回路网络，它只包含一台计算机（自身），传统上它被称为localhost，它有一个标准的IP地址170.0.0.1。这就是本地主机。\n\n\n见代码案例：example2，但这个案例有一个故意设置的错误（没有考虑主机序和网络序）。\n\n\n主机字节序和网络字节序\n\n\n使用netstat命令可以查看网络连接情况，包括连接对应的服务器和客户的端口号。\n\n\n如上例，显示的服务器套接字的端口号是错误的，这是因为没有把主机字节序转换成网络字节序（不同计算机的主机字节序可能不同，为了保证不同计算机的一致性，所以要转换成统一的网络字节序）。\n\n\n#include \nnetinet/in.h\n\n\nuint32_t htonl(uint32_t hostlong);\nuint16_t htons(uint16_t hostshort);\nuint32_t ntohl(uint32_t netlong);\nuint16_t ntohs(uint16_t netshort);\n\n\n\n\n这些函数将16位和32位整数在主机字节序和标准的网络字节序之间进行转换。函数名是与之对应的转换操作的简写形式。例如“host to network, long”（htonl，长整数从主机字节序到网络字节序的转换）。\n\n\n如果计算机的主机字节序与网络字节序相同，这些函数的内容实际上就是空操作。\n\n\n为了保证有正确的字节序，服务器和客户需要使用这些函数来进行转换：\n\n\nserver_address.sin_addr.s_addr = htonl(INADDR_ANY);\nserver_address.sin_port = htons(9734);\n\n\n\n\n但不需要对函数调用inet_addr(\"127.0.0.1\")进行转换，因为inet_addr已经被定义为产生一个网络字节序的结果。\n\n\n见example3。", 
            "title": "套接字1"
        }, 
        {
            "location": "/ch15 套接字_1/#_1", 
            "text": "套接字是一种通信机制，它明确地将客户和服务器区分开来。套接字机制可以实现多个客户端连接到一个服务器。", 
            "title": "什么是套接字"
        }, 
        {
            "location": "/ch15 套接字_1/#_2", 
            "text": "首先，服务器应用程序用系统调用socket来创建一个套接字，它是类似文件描述符的资源，不能与其他进程共享。  接下来，服务器进程会给套接字起个名字。本地套接字的名字是Linux文件系统中的文件名，一般放在/tmp或/usr/tmp目录中。对于网络套接字，它的名字是与网络有关的标识符（比如端口号）。这个标识符允许Linux将进入的针对特定端口号的连接转到正确的服务器进程。  我们用系统调用bind来给套接字命名。然后服务器进程就开始等待客户端连接到这个命名套接字。  系统调用listen的作用是，创建一个队列并将其用于存放来自客户的进入连接。服务器通过系统调用accept来接受客户的连接。  服务器调用accept时，它会创建一个新套接字，这个新套接字只用于与这个特定的客户进行通信。而命名套接字则被保留下来继续处理来自其他客户的连接。  基于套接字系统的客户端首先调用socket创建一个未命名套接字，然后将服务器的命名套接字作为一个地址，调用connect与服务器建立连接。  一旦连接建立，我们就可以开始双向的数据通信。  一个简单的案例见：client1.c, server1.c", 
            "title": "套接字连接"
        }, 
        {
            "location": "/ch15 套接字_1/#_3", 
            "text": "套接字的特性由3个属性确定：域（domain）、类型（type）和协议（protocol）。套接字还用地址作为它的名字。  套接字的域  域指定套接字通信中使用的网络介质。最常见的套接字域是AF_INET（adress format internet），它指的是Internet网络，并使用IP地址来指定网络中的计算机。  所有的IP地址都用4个数字来表示，每个数字都小于256，即所谓的点分四元组表示法（dotted quad）。  当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址。客户可以通过IP端口来指定一台联网机器上的某个特定服务。端口通过分配一个唯一的16位整数来标识。套接字必须在开始通信之前绑定一个端口。  书中第一个例子的域是UNIX文件系统域AF_UNIX，它的地址就是文件名。还有一些其他的域，但不在讨论范围。   套接字类型  因特网协议提供了了两种通信机制：流（stream）和数据报（datagram）。  流套接字  流套接字提供的是一个有序、可靠、双向字节流的连接。  流套接字由类型SOCK_STREAM指定，它们是在AF_INET域中通过TCP/IP连接实现的。  数据报套接字  由类型SOCK_DGRAM指定，它不建立和维持一个连接。它对可以发送的数据报的长度有限制。数据报作为一个单独的网络消息被传输，它可能会丢失、复制或乱序到达。  数据报套接字是在AF_INET域中通过UDP/IP连接实现的，它提供的是一种无序的不可靠服务。相对来说它们开销比较小，速度也很快。   套接字协议  UNIX网络套接字和文件系统套接字不需要选择一个特定的协议，只需要使用其默认值即可。", 
            "title": "套接字属性"
        }, 
        {
            "location": "/ch15 套接字_1/#_4", 
            "text": "socket系统调用创建一个套接字并返回一个描述符，该描述符可以用来访问该套接字。  #include  sys/types.h \n#include  sys/socket.h \n\nint socket(int domain, int type, int protocol);  创建的套接字是一条通信线路的一个端点。domain参数最常用的取值是AF_UNIX和AF_INET。type的取值可以是SOCK_STREAM和SOCK_DGRAM。protocol通常不需要选择，本章节中都是用0，表示使用默认协议。", 
            "title": "创建套接字"
        }, 
        {
            "location": "/ch15 套接字_1/#_5", 
            "text": "每个套接字域都有自己的地址格式。对于AF_UNIX域套接字来说，它的地址由结构sockaddr_un来描述：  #include  sys/un.h \n\nstruct sockaddr_un {\n    sa_family_t    sun_family;    /* AF_UNIX */\n    char           sun_path[];    /* pathname */\n};  对套接字进行处理的系统调用可能需要接受不同类型的地址，每种地址格式都使用一种类似的结构来描述，它们都以一个指定地址类型（套接字域）的成员开始。  在AF_INET域中，套接字地址由结构sockaddr_in来指定：  #include  netinet/in.h \n\nstruct sockaddr_in {\n    short int          sin_family;    /* AF_INET */\n    unsigned short int sin_port;      /* Port number */\n    struct in_addr     sin_addr;      /* Internet address */\n};  结构in_addr是IP地址：  struct in_addr {\n    unsigned long int s_addr;\n};  IP地址中的4个字节组成一个32位的值。一个AF_INET套接字由它的域、IP地址和端口号完全确定。", 
            "title": "套接字地址"
        }, 
        {
            "location": "/ch15 套接字_1/#_6", 
            "text": "想要套接字被使用，服务器程序就必须给该套接字命名。这样，AF_UNIX套接字就会关联到一个文件系统的路径名。AF_INET套接字就会关联到一个IP端口号。  #include  sys/socket.h \n\nint bind(int socket, const struct sockaddr *address, size_t address_len);  bind系统调用把参数address中的地址分配给与socket描述符关联的未命名套接字。地址结构的长度由参数address_len传递。  bind函数调用成功返回0，失败返回-1并设置errno。可取值见书本。", 
            "title": "命名套接字"
        }, 
        {
            "location": "/ch15 套接字_1/#_7", 
            "text": "为了能够在套接字上接受进入的连接，服务器程序必须创建一个队列来保存未处理的请求。  #include  sys/socket.h \n\nint listen(int socket, int backlog);  listen函数将队列长度设置为backlog参数的值，等待处理的进入连接的个数最多不能超过这个数字。再往后的连接将被拒绝，导致客户的连接请求失败。backog参数常用的值是5。  listen函数成功返回0，失败返回-1并设置errno。见书本。", 
            "title": "创建套接字队列"
        }, 
        {
            "location": "/ch15 套接字_1/#_8", 
            "text": "通过accept系统调用来等待客户建立对该套接字的连接。  #include  sys/socket.h \n\nint accept(int socket, struct sockaddr *address, size_t *address_len);  accept系统调用只有当客户程序试图连接到由socket参数指定的套接字上时才会返回。这里的客户指的是在套接字队列中排在第一个的未处理的连接。accept函数将创建一个新套接字来与该客户进行通信，并且返回新套接字的描述符。  连接客户的地址将被放入address参数指向的sockaddr结构中，如果不关心这个地址，可以设置为空指针。  参数address_len指定客户结构的长度，如果客户地址的长度超过这个值，它将被截断。这个调用返回时，address_len将被设置为连接客户地址结构的实际长度。  如果套接字队列中没有未处理的连接，accept将阻塞直到有客户建立连接为止。可以通过对套接字描述符设置O_NONBLOCK标志来改变这一行为：  int flags = fcntl(sock, F_GETFL, 0);\nfcntl(socket, F_SETFL, O_NONBLOCK|flags);  如果发生错误，accept函数将返回-1。", 
            "title": "接受连接"
        }, 
        {
            "location": "/ch15 套接字_1/#_9", 
            "text": "客户程序通过在一个未命名套接字和服务器监听套接字之间建立连接的方法来连接到服务器。  #include  sys/socket.h \n\nint connect(int socket, const struct sockaddr *address, size_t address_len);  参数socket是通过socket调用获得的一个有效的描述符，其指定的套接字将连接到参数address指定的服务器套接字，address指向的结构的长度由参数address_len指定。  成功时，connect调用返回0，失败时返回-1，并设置errno。见书本。  如果连接不能立刻建立，connect调用将阻塞一段不确定的超时时间，一旦超时时间到达，连接将被放弃，connect调用失败。  connect调用的阻塞特性可以通过设置该文件描述符的O_NONBLOCK标志来改变，此时如果连接不能立刻建立，connect将失败并把errno设置为EINPROGRESS，而连接将以异步方式继续进行。可以用select调用来检查套接字是否已处于写就绪状态。", 
            "title": "请求连接"
        }, 
        {
            "location": "/ch15 套接字_1/#_10", 
            "text": "你可以通过调用close函数来终止服务器和客户上的套接字连接。  对于服务器来说，应该在read调用返回0时关闭套接字，但如果套接字是一个面向连接类型的，并设置了SOCK_LINGER选项，close调用会在该套接字还有未传输数据时阻塞。", 
            "title": "关闭套接字"
        }, 
        {
            "location": "/ch15 套接字_1/#_11", 
            "text": "我们不能使用小于1024的端口号，因为它们是为系统使用保留的。其它的端口号信息通常列在系统文件 /etc/services 中。编写基于套接字的应用程序时，请注意总要选择没有列在该配置文件中的端口号。  我们将在局域网中运行客户和服务器。UNIX计算机通常会配置一个回路网络，它只包含一台计算机（自身），传统上它被称为localhost，它有一个标准的IP地址170.0.0.1。这就是本地主机。  见代码案例：example2，但这个案例有一个故意设置的错误（没有考虑主机序和网络序）。", 
            "title": "套接字通讯"
        }, 
        {
            "location": "/ch15 套接字_1/#_12", 
            "text": "使用netstat命令可以查看网络连接情况，包括连接对应的服务器和客户的端口号。  如上例，显示的服务器套接字的端口号是错误的，这是因为没有把主机字节序转换成网络字节序（不同计算机的主机字节序可能不同，为了保证不同计算机的一致性，所以要转换成统一的网络字节序）。  #include  netinet/in.h \n\nuint32_t htonl(uint32_t hostlong);\nuint16_t htons(uint16_t hostshort);\nuint32_t ntohl(uint32_t netlong);\nuint16_t ntohs(uint16_t netshort);  这些函数将16位和32位整数在主机字节序和标准的网络字节序之间进行转换。函数名是与之对应的转换操作的简写形式。例如“host to network, long”（htonl，长整数从主机字节序到网络字节序的转换）。  如果计算机的主机字节序与网络字节序相同，这些函数的内容实际上就是空操作。  为了保证有正确的字节序，服务器和客户需要使用这些函数来进行转换：  server_address.sin_addr.s_addr = htonl(INADDR_ANY);\nserver_address.sin_port = htons(9734);  但不需要对函数调用inet_addr(\"127.0.0.1\")进行转换，因为inet_addr已经被定义为产生一个网络字节序的结果。  见example3。", 
            "title": "主机字节序和网络字节序"
        }, 
        {
            "location": "/ch15 套接字_2/", 
            "text": "网络信息\n\n\n可以将自己的服务添加到/etc/services文件中的已知服务列表中，使用户可以使用符号化的服务名而不是端口号的数组。\n\n\n如果给定一个主机名字，可以通过调用解析地址的主机数据库函数来确定它的IP地址。这些函数通过查询网络配置文件来完成这一工作，如/etc/services文件或网络信息服务（比如NIS, DNS）。\n\n\n#include \nnetdb.h\n\n\nstruct hostent *gethostbyname(const char *name);\n\nstruct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);\n\n\n\n\n这些函数返回的结构中至少包含以下几个成员：\n\n\nstruct hostent {\n    char  *h_name;            /* official name of host */\n    char **h_aliases;         /* alias list */\n    int    h_addrtype;        /* host address type */\n    int    h_length;          /* length of address */\n    char **h_addr_list;       /* list of addresses */\n};\n\n\n\n\n如果查询失败，返回空指针。\n\n\n与服务及其关联端口号有关的信息可以通过一些服务信息函数来获取。\n\n\n#include \nnetdb.h\n\n\nstruct servent *getservbyname(const char *name, const char *proto);\n\nstruct servent *getservbyport(int port, const char *proto);\n\n\n\n\nproto参数用于指定连接该服务的协议，它的两个取值是tcp和udp。\n\n\n结构servent至少包含以下几个成员：\n\n\nstruct servent {\n    char  *s_name;       /* official service name */\n    char **s_aliases;    /* alias list */\n    int    s_port;       /* port number */\n    char  *s_proto;      /* protocol to use */\n}\n\n\n\n\n函数inet_ntoa将一个因特网主机地址转换为一个点分四元组格式的字符串。\n\n\n#include \narpa/inet.h\n\n\nchar *inet_ntoa(struct in_addr in);\n\n\n\n\ngethostname函数将当前主机的名字写入name指向的字符串中。\n\n\n#include \nunistd.h\n\n\nint gethostname(char *name, size_t len);\n\n\n\n\n主机名将以null结尾。len指定了字符串name的长度，如果返回的主机名太长，它就会被截断。成功返回0，失败返回-1。\n\n\n因特网守护进程（xinetd/inetd）\n\n\nUnix系统通常以超级服务器的方式来提供多项网络服务。\n\n\n超级服务器程序（因特网守护进程xinetd或inetd）同时监听许多端口地址上的连接。当有客户连接到某项服务时，守护进程就运行相应的服务器。这使得针对各项网络服务的服务器不需要一直运行着，它们可以在需要时启动。\n\n\n我使用的CentOS 7中默认没有安装xinetd，因此需要先安装：\n\n\n# yum install xinetd\n\n\n\n\n接着去这个目录修改某一个服务的配置文件，比如daytime：/etc/xinetd.d\n\n\n把配置文件中的disable选项的值设置成no，代表开启。\n\n\n然后启动xinetd：\n\n\n# systemctl start xinetd\n\n\n\n\n其它细节见书本。\n\n\n套接字选项\n\n\n可以用许多选项来控制套接字的行为，可以使用setsockopt函数用于控制这些选项。\n\n\n#include \nsys/socket.h\n\n\nint setsockopt(int socket, int level, int option_name, const void *option_value, size_t option_len);\n\n\n\n\n可以在协议层次的不同级别对选项进行设置。如果想要在套接字级别设置选项，就必须将level参数设置为SOL_SOCKET。\n\n\noption_name参数指定要设置的选项；option_value参数的长度为option_len字节，它用于设置选项的新值。\n\n\nsetsockopt在成功时返回0，失败时返回-1。\n\n\n详细细节见书本。不过书本也是略微介绍而已。", 
            "title": "套接字2"
        }, 
        {
            "location": "/ch15 套接字_2/#_1", 
            "text": "可以将自己的服务添加到/etc/services文件中的已知服务列表中，使用户可以使用符号化的服务名而不是端口号的数组。  如果给定一个主机名字，可以通过调用解析地址的主机数据库函数来确定它的IP地址。这些函数通过查询网络配置文件来完成这一工作，如/etc/services文件或网络信息服务（比如NIS, DNS）。  #include  netdb.h \n\nstruct hostent *gethostbyname(const char *name);\n\nstruct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);  这些函数返回的结构中至少包含以下几个成员：  struct hostent {\n    char  *h_name;            /* official name of host */\n    char **h_aliases;         /* alias list */\n    int    h_addrtype;        /* host address type */\n    int    h_length;          /* length of address */\n    char **h_addr_list;       /* list of addresses */\n};  如果查询失败，返回空指针。  与服务及其关联端口号有关的信息可以通过一些服务信息函数来获取。  #include  netdb.h \n\nstruct servent *getservbyname(const char *name, const char *proto);\n\nstruct servent *getservbyport(int port, const char *proto);  proto参数用于指定连接该服务的协议，它的两个取值是tcp和udp。  结构servent至少包含以下几个成员：  struct servent {\n    char  *s_name;       /* official service name */\n    char **s_aliases;    /* alias list */\n    int    s_port;       /* port number */\n    char  *s_proto;      /* protocol to use */\n}  函数inet_ntoa将一个因特网主机地址转换为一个点分四元组格式的字符串。  #include  arpa/inet.h \n\nchar *inet_ntoa(struct in_addr in);  gethostname函数将当前主机的名字写入name指向的字符串中。  #include  unistd.h \n\nint gethostname(char *name, size_t len);  主机名将以null结尾。len指定了字符串name的长度，如果返回的主机名太长，它就会被截断。成功返回0，失败返回-1。", 
            "title": "网络信息"
        }, 
        {
            "location": "/ch15 套接字_2/#xinetdinetd", 
            "text": "Unix系统通常以超级服务器的方式来提供多项网络服务。  超级服务器程序（因特网守护进程xinetd或inetd）同时监听许多端口地址上的连接。当有客户连接到某项服务时，守护进程就运行相应的服务器。这使得针对各项网络服务的服务器不需要一直运行着，它们可以在需要时启动。  我使用的CentOS 7中默认没有安装xinetd，因此需要先安装：  # yum install xinetd  接着去这个目录修改某一个服务的配置文件，比如daytime：/etc/xinetd.d  把配置文件中的disable选项的值设置成no，代表开启。  然后启动xinetd：  # systemctl start xinetd  其它细节见书本。", 
            "title": "因特网守护进程（xinetd/inetd）"
        }, 
        {
            "location": "/ch15 套接字_2/#_2", 
            "text": "可以用许多选项来控制套接字的行为，可以使用setsockopt函数用于控制这些选项。  #include  sys/socket.h \n\nint setsockopt(int socket, int level, int option_name, const void *option_value, size_t option_len);  可以在协议层次的不同级别对选项进行设置。如果想要在套接字级别设置选项，就必须将level参数设置为SOL_SOCKET。  option_name参数指定要设置的选项；option_value参数的长度为option_len字节，它用于设置选项的新值。  setsockopt在成功时返回0，失败时返回-1。  详细细节见书本。不过书本也是略微介绍而已。", 
            "title": "套接字选项"
        }, 
        {
            "location": "/ch15 套接字_3/", 
            "text": "多客户\n\n\n考虑有多个客户同时连接一个服务器的情况。服务器程序在接受来自客户的一个新连接时，会创建出一个新的套接字，而原先的监听套接字将被保留以继续监听以后的连接。如果服务器不能立刻接受后来的连接，它们将被放到队列中以等待处理。\n\n\n原先的套接字仍然可用并且套接字的行为就像文件描述符，这一事实给我们提供了一种同时服务多个客户的方法。如果服务器调用fork为自己创建第二份副本，打开的新套接字就将被新的子进程所继承。新的子进程可以和连接的客户进行通信，而主服务器进程可以继续接受以后的客户连接。\n\n\n由于我们创建子进程，但并不等待它们完成，所以必须安排服务器忽略SIGCHLD信号以避免出现僵尸进程。\n\n\n\n\n个人理解：这里所说的方法即是：每当接受（accept）队列中一个连接后，就fork一个子进程，由子进程使用新获得的sockfd和客户通信。而父进程继续处理以后的客户连接。\n\n\n\n\n事例代码见example4。\n\n\nselect系统调用\n\n\nselect系统调用允许程序同时在多个底层文件描述符上等待输入的到达（或输出的完成）。这意味着终端仿真程序可以一直阻塞到有事情可做为止。类似地，服务器也可以通过同时在多个打开的套接字上等待请求到来的方法来处理多个客户。\n\n\nselect函数对数据结构fd_set进行操作，它是由打开的文件描述符构成的集合。有一组定义好的宏可以用来控制这些集合：\n\n\n#include \nsys/time.h\n\n#include \nsys/types.h\n\n\nvoid FD_CLR(int fd, fd_set *set);\nint  FD_ISSET(int fd, fd_set *set);\nvoid FD_SET(int fd, fd_set *set);\nvoid FD_ZERO(fd_set *set);\n\n\n\n\nFD_ZERO用于将fd_set初始化为空集合，FD_SET和FD_CLR分别用于在集合中设置和清除由参数fd传递的文件描述符。如果FD_ISSET宏中由参数fd指向的文件描述符是由参数fdset指向的fd_set集合中的一个元素，FD_ISSET将返回非零值。\n\n\nfd_set结构中可以容纳的文件描述符的最大数目由常量FD_SETSIZE指定。\n\n\nselect函数用一个超时值来防止无限期的阻塞，这个超时值由一个timeval结构给出。\n\n\nstruct timeval {\n    long    tv_sec;         /* seconds */\n    long    tv_usec;        /* microseconds */\n};\n\n\n\n\nselect系统调用的原型如下：\n\n\n#include \nsys/time.h\n\n#include \nsys/types.h\n\n\nint select(int nfds, fd_set *readfds, fd_set *writefds,\n                  fd_set *exceptfds, struct timeval *timeout);\n\n\n\n\nselect调用用于测试文件描述符集合中，是否有一个文件描述符已处于可读状态或可写状态或错误状态，它将阻塞以等待某个文件描述符进入这些状态。\n\n\n参数nfds指定需要测试的文件描述符数目，测试的描述符范围从0到nfds-1。3个描述符集合都可以被设置为空指针，这表示不执行相应的测试。\n\n\nselect函数会在发生以下情况时返回：readfds中有描述符可读、writefds中有描述符可写或errorfds中有描述符遇到错误条件。如果这3种情况都没有发生，select将在timeout指定的超时时间经过后返回，如果timeout是一个空指针，这个调用会一直阻塞下去。\n\n\n当select返回时，描述符集合将被修改以指示哪些描述符正处于可读、可写或有错误的状态。可以使用FD_ISSET对描述符进行测试，来找出需要注意的描述符。\n\n\nselect调用返回状态发生变化的描述符总数。失败时它将返回-1并设置errno。timeout参数指向的结构可能还会被修改为剩余的超时时间。\n\n\n见代码案例：select.c。\n\n\n多客户\n\n\n通过使用select调用来同时处理多个客户就无需依赖于子进程了。但在把这个技巧应用到实际的应用程序中时，必须要注意，不能在处理第一个连接的客户时让其他客户等太长的时间。\n\n\n服务器可以使用select调用同时检查监听套接字和客户连接的套接字。一旦select调用指示有活动发生，就可以调用FD_ISSET来遍历所有可能的文件描述符，以检查是哪个上面有活动发生。\n\n\n如果是监听套接字可读，说明正有一个客户试图建立连接，此时就可以调用accept而不必担心其阻塞。如果是客户描述符准备好，说明有一个客户请求需要我们读取和处理。\n\n\n见代码案例：example5。\n\n\n数据报\n\n\n当客户需要发送一个短小的查询请求给服务器，并且期望接收到一个短小的响应时，我们一般就使用由UDP服务提供的服务。\n\n\nsendto系统调用从buffer缓冲区中给使用指定套接字地址的目标服务器发送一个数据报。它的原型如下所示：\n\n\nint sendto(int sockfd, const void *buf, size_t len, int flags,\n               const struct sockaddr *dest_addr, socklen_t addrlen);\n\n\n\n\n在正常应用中，flag参数一般被设置为0。\n\n\nrecvfrom系统调用在套接字上等待从特定地址到来的数据报，并将它放入buffer缓冲区。它的原型如下所示：\n\n\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,\n                 struct sockaddr *src_addr, socklen_t *addrlen);\n\n\n\n\n同样，在正常应用中，flag参数一般被设置为0。\n\n\n当错误发生时，sendto和recvfrom都将返回-1并设置errno。\n\n\n除非用fcntl将套接字设置为非阻塞方式，否则recvfrom调用将一直阻塞。我们可以用与前面的面向连接服务器一样的方式，通过select调用和超时设置来判断是否有数据到达套接字。", 
            "title": "套接字3"
        }, 
        {
            "location": "/ch15 套接字_3/#_1", 
            "text": "考虑有多个客户同时连接一个服务器的情况。服务器程序在接受来自客户的一个新连接时，会创建出一个新的套接字，而原先的监听套接字将被保留以继续监听以后的连接。如果服务器不能立刻接受后来的连接，它们将被放到队列中以等待处理。  原先的套接字仍然可用并且套接字的行为就像文件描述符，这一事实给我们提供了一种同时服务多个客户的方法。如果服务器调用fork为自己创建第二份副本，打开的新套接字就将被新的子进程所继承。新的子进程可以和连接的客户进行通信，而主服务器进程可以继续接受以后的客户连接。  由于我们创建子进程，但并不等待它们完成，所以必须安排服务器忽略SIGCHLD信号以避免出现僵尸进程。   个人理解：这里所说的方法即是：每当接受（accept）队列中一个连接后，就fork一个子进程，由子进程使用新获得的sockfd和客户通信。而父进程继续处理以后的客户连接。   事例代码见example4。", 
            "title": "多客户"
        }, 
        {
            "location": "/ch15 套接字_3/#select", 
            "text": "select系统调用允许程序同时在多个底层文件描述符上等待输入的到达（或输出的完成）。这意味着终端仿真程序可以一直阻塞到有事情可做为止。类似地，服务器也可以通过同时在多个打开的套接字上等待请求到来的方法来处理多个客户。  select函数对数据结构fd_set进行操作，它是由打开的文件描述符构成的集合。有一组定义好的宏可以用来控制这些集合：  #include  sys/time.h \n#include  sys/types.h \n\nvoid FD_CLR(int fd, fd_set *set);\nint  FD_ISSET(int fd, fd_set *set);\nvoid FD_SET(int fd, fd_set *set);\nvoid FD_ZERO(fd_set *set);  FD_ZERO用于将fd_set初始化为空集合，FD_SET和FD_CLR分别用于在集合中设置和清除由参数fd传递的文件描述符。如果FD_ISSET宏中由参数fd指向的文件描述符是由参数fdset指向的fd_set集合中的一个元素，FD_ISSET将返回非零值。  fd_set结构中可以容纳的文件描述符的最大数目由常量FD_SETSIZE指定。  select函数用一个超时值来防止无限期的阻塞，这个超时值由一个timeval结构给出。  struct timeval {\n    long    tv_sec;         /* seconds */\n    long    tv_usec;        /* microseconds */\n};  select系统调用的原型如下：  #include  sys/time.h \n#include  sys/types.h \n\nint select(int nfds, fd_set *readfds, fd_set *writefds,\n                  fd_set *exceptfds, struct timeval *timeout);  select调用用于测试文件描述符集合中，是否有一个文件描述符已处于可读状态或可写状态或错误状态，它将阻塞以等待某个文件描述符进入这些状态。  参数nfds指定需要测试的文件描述符数目，测试的描述符范围从0到nfds-1。3个描述符集合都可以被设置为空指针，这表示不执行相应的测试。  select函数会在发生以下情况时返回：readfds中有描述符可读、writefds中有描述符可写或errorfds中有描述符遇到错误条件。如果这3种情况都没有发生，select将在timeout指定的超时时间经过后返回，如果timeout是一个空指针，这个调用会一直阻塞下去。  当select返回时，描述符集合将被修改以指示哪些描述符正处于可读、可写或有错误的状态。可以使用FD_ISSET对描述符进行测试，来找出需要注意的描述符。  select调用返回状态发生变化的描述符总数。失败时它将返回-1并设置errno。timeout参数指向的结构可能还会被修改为剩余的超时时间。  见代码案例：select.c。", 
            "title": "select系统调用"
        }, 
        {
            "location": "/ch15 套接字_3/#_2", 
            "text": "通过使用select调用来同时处理多个客户就无需依赖于子进程了。但在把这个技巧应用到实际的应用程序中时，必须要注意，不能在处理第一个连接的客户时让其他客户等太长的时间。  服务器可以使用select调用同时检查监听套接字和客户连接的套接字。一旦select调用指示有活动发生，就可以调用FD_ISSET来遍历所有可能的文件描述符，以检查是哪个上面有活动发生。  如果是监听套接字可读，说明正有一个客户试图建立连接，此时就可以调用accept而不必担心其阻塞。如果是客户描述符准备好，说明有一个客户请求需要我们读取和处理。  见代码案例：example5。", 
            "title": "多客户"
        }, 
        {
            "location": "/ch15 套接字_3/#_3", 
            "text": "当客户需要发送一个短小的查询请求给服务器，并且期望接收到一个短小的响应时，我们一般就使用由UDP服务提供的服务。  sendto系统调用从buffer缓冲区中给使用指定套接字地址的目标服务器发送一个数据报。它的原型如下所示：  int sendto(int sockfd, const void *buf, size_t len, int flags,\n               const struct sockaddr *dest_addr, socklen_t addrlen);  在正常应用中，flag参数一般被设置为0。  recvfrom系统调用在套接字上等待从特定地址到来的数据报，并将它放入buffer缓冲区。它的原型如下所示：  ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,\n                 struct sockaddr *src_addr, socklen_t *addrlen);  同样，在正常应用中，flag参数一般被设置为0。  当错误发生时，sendto和recvfrom都将返回-1并设置errno。  除非用fcntl将套接字设置为非阻塞方式，否则recvfrom调用将一直阻塞。我们可以用与前面的面向连接服务器一样的方式，通过select调用和超时设置来判断是否有数据到达套接字。", 
            "title": "数据报"
        }
    ]
}