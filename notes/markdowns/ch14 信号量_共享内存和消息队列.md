# 第十四章 信号量、共享内存和消息队列

本章讨论了一组进程间通信的机制，它们常被称为 IPC ( Inter-Process Communication ) 。

包括：

- 信号量：用于管理对资源的访问。

- 共享内存：用于在程序间高效地共享数据。

- 消息队列：在程序之间传递数据的一种简单方法。

---

## 信号量

程序可能拥有着所谓的临界代码，需要被确保只有一个进程（或一个执行线程）可以进入这个临界代码并拥有对资源独占式的访问。

信号量是一种特殊的变量，它只取正整数值，并且程序对其访问都是原子操作。只允许对它进行等待（ wait ）和发送信号（ signal ）两种操作，可以用 P 和 V 来代替（因 wait 和 signal 已经有特殊含义）。

!!!note
    P 和 V 这俩字母来自荷兰单词，因为信号量的概念是荷兰计算机科学家 Dijkstra 提出的。

### 信号量的定义

最简单的信号量是只能取值0和1的变量，即二进制信号量。可以取多个正整数值的信号量被称为通用信号量。

假设有一个信号量变量 sv ， PV 操作的含义是：

|操作|含义|
|-|-|
|P|如果 sv 的值大于零，就给它减去1；如果它的值等于零，就挂起该进程的执行|
|V|如果有其他进程因等待 sv 而被挂起，就让它恢复运行；如果没有进程因等待 sv 而被挂起，就给它加1|

### 一个理论性的例子

两个进程共享信号量变量 sv 。一旦其中一个进程执行了 P(SV) 操作，它将得到信号量，并可以进入临界区域。而第二个进程将被阻止进入临界区域，因为当它试图执行 P(sv) 操作时，它会被挂起以等待第一个进程离开临界区域并执行 V(sv) 操作释放信号量。

用伪代码说明，则如：

```
semaphore sv = 1;

loop forever {
    P(sv);
    critical code section;
    V(sv);
    noncritical code section;
}
```

### Linux 的信号量机制

所有的 Linux 信号量函数都是针对成组的通用信号进行操作，而不是只针对一个二进制信号量。本章仅讨论了单个信号量的使用，在绝大多数情况下，使用它就足够了。

[semget 函数](../codes/lab/api/IPC/semget.c "semget.c") 可以获取信号量或创建信号量。

```c
int semget(key_t key, int num_sems, int sem_flags);
```

key 用于获取系统维护的信号量，它返回的是信号量标识符 sem_id 。之后的信号量函数采用 sem_id 来作为句柄。

不相关的进程可以访问到同一个信号量。

[semop 函数](../codes/lab/api/IPC/semop.c "semop.c") 用于改变信号量的值，即采取 PV 操作。 

[semctl 函数](../codes/lab/api/IPC/semctl.c "semctl.c") 用于直接控制信号量信息。它可以初始化信号量，或者删除信号量。

信号量如果不删除，它将继续在系统中存在。